// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios13.1-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name GRDB
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CoreGraphics
import Dispatch
import Foundation
@_exported import GRDB
@_exported import SQLite3
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct SQLOrdering {
}
public protocol SQLOrderingTerm {
  var sqlOrdering: GRDB.SQLOrdering { get }
}
extension GRDB.SQLOrdering : GRDB.SQLOrderingTerm {
  @available(*, deprecated, message: "Already QLOrdering:")
  public var sqlOrdering: GRDB.SQLOrdering {
    get
  }
}
extension Swift.Optional : GRDB.StatementBinding where Wrapped : GRDB.StatementBinding {
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Optional : GRDB.SQLExpressible where Wrapped : GRDB.SQLExpressible {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
extension Swift.Optional : GRDB.SQLOrderingTerm where Wrapped : GRDB.SQLOrderingTerm {
  public var sqlOrdering: GRDB.SQLOrdering {
    get
  }
}
extension Swift.Optional : GRDB.SQLSelectable where Wrapped : GRDB.SQLSelectable {
  public var sqlSelection: GRDB.SQLSelection {
    get
  }
}
extension Swift.Optional : GRDB.SQLSpecificExpressible where Wrapped : GRDB.SQLSpecificExpressible {
}
extension Swift.Optional : GRDB.DatabaseValueConvertible where Wrapped : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromMissingColumn() -> Swift.Optional<Wrapped>?
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Optional<Wrapped>?
}
extension Swift.Optional : GRDB.StatementColumnConvertible where Wrapped : GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public static func fromStatement(_ sqliteStatement: GRDB.SQLiteStatement, atUncheckedIndex index: Swift.CInt) -> Swift.Optional<Wrapped>? {
        if let value = Wrapped.fromStatement(sqliteStatement, atUncheckedIndex: index) {
            // Valid value
            return value
        } else if sqlite3_column_type(sqliteStatement, index) == SQLITE_NULL {
            // NULL
            return .some(.none)
        } else {
            // Invalid value
            return .none
        }
    }
  public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
}
extension GRDB.AssociationToMany {
  public var count: GRDB.AssociationAggregate<Self.OriginRowDecoder> {
    get
  }
  public var isEmpty: GRDB.AssociationAggregate<Self.OriginRowDecoder> {
    get
  }
  public func average(_ expression: some SQLSpecificExpressible) -> GRDB.AssociationAggregate<Self.OriginRowDecoder>
  public func max(_ expression: some SQLSpecificExpressible) -> GRDB.AssociationAggregate<Self.OriginRowDecoder>
  public func min(_ expression: some SQLSpecificExpressible) -> GRDB.AssociationAggregate<Self.OriginRowDecoder>
  public func sum(_ expression: some SQLSpecificExpressible) -> GRDB.AssociationAggregate<Self.OriginRowDecoder>
  public func total(_ expression: some SQLSpecificExpressible) -> GRDB.AssociationAggregate<Self.OriginRowDecoder>
}
public struct AssociationAggregate<RowDecoder> {
}
extension GRDB.AssociationAggregate {
  public func forKey(_ key: Swift.String) -> GRDB.AssociationAggregate<RowDecoder>
  public func forKey(_ key: some CodingKey) -> GRDB.AssociationAggregate<RowDecoder>
}
extension GRDB.AssociationAggregate {
  prefix public static func ! (aggregate: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func && (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func && (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func && (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func || (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func || (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func || (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
}
extension GRDB.AssociationAggregate {
  public static func == (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func == (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: (any GRDB.SQLExpressible)?) -> GRDB.AssociationAggregate<RowDecoder>
  public static func == (lhs: (any GRDB.SQLExpressible)?, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func == (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: Swift.Bool) -> GRDB.AssociationAggregate<RowDecoder>
  public static func == (lhs: Swift.Bool, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func != (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func != (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: (any GRDB.SQLExpressible)?) -> GRDB.AssociationAggregate<RowDecoder>
  public static func != (lhs: (any GRDB.SQLExpressible)?, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func != (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: Swift.Bool) -> GRDB.AssociationAggregate<RowDecoder>
  public static func != (lhs: Swift.Bool, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func === (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func === (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: (any GRDB.SQLExpressible)?) -> GRDB.AssociationAggregate<RowDecoder>
  public static func === (lhs: (any GRDB.SQLExpressible)?, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func !== (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func !== (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: (any GRDB.SQLExpressible)?) -> GRDB.AssociationAggregate<RowDecoder>
  public static func !== (lhs: (any GRDB.SQLExpressible)?, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
}
extension GRDB.AssociationAggregate {
  public static func <= (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func <= (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func <= (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func < (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func < (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func < (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func > (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func > (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func > (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func >= (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func >= (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func >= (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
}
extension GRDB.AssociationAggregate {
  prefix public static func - (aggregate: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func + (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func + (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func + (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func - (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func - (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func - (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func * (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func * (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func * (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func / (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
  public static func / (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
  public static func / (lhs: some SQLExpressible, rhs: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
}
extension GRDB.AssociationAggregate {
  public static func ?? (lhs: GRDB.AssociationAggregate<RowDecoder>, rhs: some SQLExpressible) -> GRDB.AssociationAggregate<RowDecoder>
}
public func abs<RowDecoder>(_ aggregate: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
public func length<RowDecoder>(_ aggregate: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.AssociationAggregate<RowDecoder>
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol TypedRequest<RowDecoder> {
  associatedtype RowDecoder
}
#else
public protocol TypedRequest {
  associatedtype RowDecoder
}
#endif
public protocol SelectionRequest {
  func selectWhenConnected(_ selection: @escaping (GRDB.Database) throws -> [any GRDB.SQLSelectable]) -> Self
  func annotatedWhenConnected(with selection: @escaping (GRDB.Database) throws -> [any GRDB.SQLSelectable]) -> Self
}
extension GRDB.SelectionRequest {
  public func select(_ selection: [any GRDB.SQLSelectable]) -> Self
  public func select(_ selection: any GRDB.SQLSelectable...) -> Self
  public func select(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> Self
  public func select(literal sqlLiteral: GRDB.SQL) -> Self
  public func annotated(with selection: [any GRDB.SQLSelectable]) -> Self
  public func annotated(with selection: any GRDB.SQLSelectable...) -> Self
}
public protocol FilteredRequest {
  func filterWhenConnected(_ predicate: @escaping (GRDB.Database) throws -> any GRDB.SQLExpressible) -> Self
}
extension GRDB.FilteredRequest {
  public func filter(_ predicate: some SQLSpecificExpressible) -> Self
  public func filter(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> Self
  public func filter(literal sqlLiteral: GRDB.SQL) -> Self
  public func none() -> Self
  public func all() -> Self
}
public protocol TableRequest {
  var databaseTableName: Swift.String { get }
  func aliased(_ alias: GRDB.TableAlias) -> Self
}
extension GRDB.TableRequest where Self : GRDB.FilteredRequest, Self : GRDB.TypedRequest {
  public func filter(key: some DatabaseValueConvertible) -> Self
  public func filter<Sequence>(keys: Sequence) -> Self where Sequence : Swift.Sequence, Sequence.Element : GRDB.DatabaseValueConvertible
  public func filter(key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]?) -> Self
  public func filter(keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) -> Self
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.TableRequest where Self : GRDB.FilteredRequest, Self : GRDB.TypedRequest, Self.RowDecoder : Swift.Identifiable, Self.RowDecoder.ID : GRDB.DatabaseValueConvertible {
  public func filter(id: Self.RowDecoder.ID) -> Self
  public func filter<IDS>(ids: IDS) -> Self where IDS : Swift.Collection, IDS.Element : GRDB.DatabaseValueConvertible, IDS.Element == Self.RowDecoder.ID
}
extension GRDB.TableRequest where Self : GRDB.OrderedRequest {
  public func orderByPrimaryKey() -> Self
}
extension GRDB.TableRequest where Self : GRDB.AggregatingRequest {
  public func groupByPrimaryKey() -> Self
}
public protocol AggregatingRequest {
  func groupWhenConnected(_ expressions: @escaping (GRDB.Database) throws -> [any GRDB.SQLExpressible]) -> Self
  func havingWhenConnected(_ predicate: @escaping (GRDB.Database) throws -> any GRDB.SQLExpressible) -> Self
}
extension GRDB.AggregatingRequest {
  public func group(_ expressions: [any GRDB.SQLExpressible]) -> Self
  public func group(_ expressions: any GRDB.SQLExpressible...) -> Self
  public func group(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> Self
  public func group(literal sqlLiteral: GRDB.SQL) -> Self
  public func having(_ predicate: some SQLExpressible) -> Self
  public func having(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> Self
  public func having(literal sqlLiteral: GRDB.SQL) -> Self
}
public protocol OrderedRequest {
  func orderWhenConnected(_ orderings: @escaping (GRDB.Database) throws -> [any GRDB.SQLOrderingTerm]) -> Self
  func reversed() -> Self
  func unordered() -> Self
}
extension GRDB.OrderedRequest {
  public func order(_ orderings: any GRDB.SQLOrderingTerm...) -> Self
  public func order(_ orderings: [any GRDB.SQLOrderingTerm]) -> Self
  public func order(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> Self
  public func order(literal sqlLiteral: GRDB.SQL) -> Self
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol JoinableRequest<RowDecoder> : GRDB.TypedRequest {
  func _including(all association: GRDB._SQLAssociation) -> Self
  func _including(optional association: GRDB._SQLAssociation) -> Self
  func _including(required association: GRDB._SQLAssociation) -> Self
  func _joining(optional association: GRDB._SQLAssociation) -> Self
  func _joining(required association: GRDB._SQLAssociation) -> Self
}
#else
public protocol JoinableRequest : GRDB.TypedRequest {
  func _including(all association: GRDB._SQLAssociation) -> Self
  func _including(optional association: GRDB._SQLAssociation) -> Self
  func _including(required association: GRDB._SQLAssociation) -> Self
  func _joining(optional association: GRDB._SQLAssociation) -> Self
  func _joining(required association: GRDB._SQLAssociation) -> Self
}
#endif
extension GRDB.JoinableRequest {
  public func including<A>(all association: A) -> Self where A : GRDB.AssociationToMany, Self.RowDecoder == A.OriginRowDecoder
  public func including<A>(optional association: A) -> Self where A : GRDB.Association, Self.RowDecoder == A.OriginRowDecoder
  public func including<A>(required association: A) -> Self where A : GRDB.Association, Self.RowDecoder == A.OriginRowDecoder
  public func joining<A>(optional association: A) -> Self where A : GRDB.Association, Self.RowDecoder == A.OriginRowDecoder
  public func joining<A>(required association: A) -> Self where A : GRDB.Association, Self.RowDecoder == A.OriginRowDecoder
}
extension GRDB.JoinableRequest where Self : GRDB.SelectionRequest {
  public func annotated<A>(withOptional association: A) -> Self where A : GRDB.Association, Self.RowDecoder == A.OriginRowDecoder
  public func annotated<A>(withRequired association: A) -> Self where A : GRDB.Association, Self.RowDecoder == A.OriginRowDecoder
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol DerivableRequest<RowDecoder> : GRDB.AggregatingRequest, GRDB.FilteredRequest, GRDB.JoinableRequest, GRDB.OrderedRequest, GRDB.SelectionRequest, GRDB.TableRequest {
  func distinct() -> Self
  func with<RowDecoder>(_ cte: GRDB.CommonTableExpression<RowDecoder>) -> Self
}
#else
public protocol DerivableRequest : GRDB.AggregatingRequest, GRDB.FilteredRequest, GRDB.JoinableRequest, GRDB.OrderedRequest, GRDB.SelectionRequest, GRDB.TableRequest {
  func distinct() -> Self
  func with<RowDecoder>(_ cte: GRDB.CommonTableExpression<RowDecoder>) -> Self
}
#endif
extension GRDB.DerivableRequest {
  public func annotated(with aggregates: GRDB.AssociationAggregate<Self.RowDecoder>...) -> Self
  public func annotated(with aggregates: [GRDB.AssociationAggregate<Self.RowDecoder>]) -> Self
  public func having(_ predicate: GRDB.AssociationAggregate<Self.RowDecoder>) -> Self
}
extension GRDB.TableRecord {
  public static func all() -> GRDB.QueryInterfaceRequest<Self>
  public static func none() -> GRDB.QueryInterfaceRequest<Self>
  public static func select(_ selection: any GRDB.SQLSelectable...) -> GRDB.QueryInterfaceRequest<Self>
  public static func select(_ selection: [any GRDB.SQLSelectable]) -> GRDB.QueryInterfaceRequest<Self>
  public static func select(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> GRDB.QueryInterfaceRequest<Self>
  public static func select(literal sqlLiteral: GRDB.SQL) -> GRDB.QueryInterfaceRequest<Self>
  public static func select<RowDecoder>(_ selection: [any GRDB.SQLSelectable], as type: RowDecoder.Type = RowDecoder.self) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(_ selection: any GRDB.SQLSelectable..., as type: RowDecoder.Type = RowDecoder.self) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), as type: RowDecoder.Type = RowDecoder.self) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(literal sqlLiteral: GRDB.SQL, as type: RowDecoder.Type = RowDecoder.self) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public static func selectPrimaryKey<PrimaryKey>(as type: PrimaryKey.Type = PrimaryKey.self) -> GRDB.QueryInterfaceRequest<PrimaryKey>
  public static func annotated(with selection: [any GRDB.SQLSelectable]) -> GRDB.QueryInterfaceRequest<Self>
  public static func annotated(with selection: any GRDB.SQLSelectable...) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter(_ predicate: some SQLSpecificExpressible) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter(key: some DatabaseValueConvertible) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter<Keys>(keys: Keys) -> GRDB.QueryInterfaceRequest<Self> where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
  public static func filter(key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]?) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter(keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter(literal sqlLiteral: GRDB.SQL) -> GRDB.QueryInterfaceRequest<Self>
  public static func order(_ orderings: any GRDB.SQLOrderingTerm...) -> GRDB.QueryInterfaceRequest<Self>
  public static func order(_ orderings: [any GRDB.SQLOrderingTerm]) -> GRDB.QueryInterfaceRequest<Self>
  public static func orderByPrimaryKey() -> GRDB.QueryInterfaceRequest<Self>
  public static func order(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> GRDB.QueryInterfaceRequest<Self>
  public static func order(literal sqlLiteral: GRDB.SQL) -> GRDB.QueryInterfaceRequest<Self>
  public static func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> GRDB.QueryInterfaceRequest<Self>
  public static func aliased(_ alias: GRDB.TableAlias) -> GRDB.QueryInterfaceRequest<Self>
  public static func with<RowDecoder>(_ cte: GRDB.CommonTableExpression<RowDecoder>) -> GRDB.QueryInterfaceRequest<Self>
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.TableRecord where Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  public static func filter(id: Self.ID) -> GRDB.QueryInterfaceRequest<Self>
  public static func filter<IDS>(ids: IDS) -> GRDB.QueryInterfaceRequest<Self> where IDS : Swift.Collection, Self.ID == IDS.Element
}
public protocol _ValueReducer {
  associatedtype Fetched
  associatedtype Value
  mutating func _value(_ fetched: Self.Fetched) throws -> Self.Value?
}
public protocol ValueReducer : GRDB._ValueReducer {
  func _fetch(_ db: GRDB.Database) throws -> Self.Fetched
}
public enum ValueReducers {
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol FetchRequest<RowDecoder> : GRDB.DatabaseRegionConvertible, GRDB.SQLSubqueryable {
  associatedtype RowDecoder
  func makePreparedRequest(_ db: GRDB.Database, forSingleResult singleResult: Swift.Bool) throws -> GRDB.PreparedRequest
  func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
}
#else
public protocol FetchRequest : GRDB.DatabaseRegionConvertible, GRDB.SQLSubqueryable {
  associatedtype RowDecoder
  func makePreparedRequest(_ db: GRDB.Database, forSingleResult singleResult: Swift.Bool) throws -> GRDB.PreparedRequest
  func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
}
#endif
extension GRDB.FetchRequest {
  public func databaseRegion(_ db: GRDB.Database) throws -> GRDB.DatabaseRegion
}
public struct PreparedRequest {
  public var statement: GRDB.Statement
  public var adapter: (any GRDB.RowAdapter)?
}
extension GRDB.FetchRequest {
  public func adapted(_ adapter: @escaping (GRDB.Database) throws -> any GRDB.RowAdapter) -> GRDB.AdaptedFetchRequest<Self>
}
public struct AdaptedFetchRequest<Base> where Base : GRDB.FetchRequest {
}
extension GRDB.AdaptedFetchRequest : GRDB.SQLSubqueryable {
  public var sqlSubquery: GRDB.SQLSubquery {
    get
  }
}
extension GRDB.AdaptedFetchRequest : GRDB.FetchRequest {
  public typealias RowDecoder = Base.RowDecoder
  public func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
  public func makePreparedRequest(_ db: GRDB.Database, forSingleResult singleResult: Swift.Bool = false) throws -> GRDB.PreparedRequest
}
public struct AnyFetchRequest<RowDecoder> {
  public func asRequest<T>(of type: T.Type) -> GRDB.AnyFetchRequest<T>
}
extension GRDB.AnyFetchRequest {
  public init(_ request: some FetchRequest<RowDecoder>)
}
extension GRDB.AnyFetchRequest : GRDB.SQLSubqueryable {
  public var sqlSubquery: GRDB.SQLSubquery {
    get
  }
}
extension GRDB.AnyFetchRequest : GRDB.FetchRequest {
  public func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
  public func makePreparedRequest(_ db: GRDB.Database, forSingleResult singleResult: Swift.Bool = false) throws -> GRDB.PreparedRequest
}
extension GRDB.Association {
  @available(*, unavailable, message: "limit(_:offset:) was not working properly, and was removed.")
  public func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> Self
}
extension GRDB.Database {
  @available(*, unavailable, renamed: "cachedStatement(sql:)")
  final public func cachedSelectStatement(sql: Swift.String) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "cachedStatement(literal:)")
  final public func cachedSelectStatement(literal sqlLiteral: GRDB.SQL) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "cachedStatement(sql:)")
  final public func cachedUpdateStatement(sql: Swift.String) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "cachedStatement(sql:)")
  final public func cachedUpdateStatement(literal sqlLiteral: GRDB.SQL) throws -> GRDB.Statement
  @available(*, unavailable, message: "Use Database.isSQLiteInternalTable(_:) static method instead.")
  final public func isSQLiteInternalTable(_ tableName: Swift.String) -> Swift.Bool
  @available(*, unavailable, message: "Use Database.isGRDBInternalTable(_:) static method instead.")
  final public func isGRDBInternalTable(_ tableName: Swift.String) -> Swift.Bool
  @available(*, unavailable, renamed: "makeStatement(sql:)")
  final public func makeSelectStatement(sql: Swift.String) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "makeStatement(literal:)")
  final public func makeSelectStatement(literal sqlLiteral: GRDB.SQL) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "makeStatement(sql:)")
  final public func makeUpdateStatement(sql: Swift.String) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "makeStatement(literal:)")
  final public func makeUpdateStatement(literal sqlLiteral: GRDB.SQL) throws -> GRDB.Statement
  @available(*, unavailable, renamed: "afterNextTransaction(onCommit:)")
  final public func afterNextTransactionCommit(_ closure: @escaping (GRDB.Database) -> Swift.Void)
}
extension GRDB.DatabaseCursor {
  @available(*, unavailable, message: "statement has been removed. You may use other cursor properties instead.")
  public var statement: GRDB.Statement {
    get
  }
}
extension GRDB.DatabaseMigrator {
  @available(*, unavailable, message: "The completion function now accepts one Result<Database, Error> argument")
  public func asyncMigrate(_ writer: any GRDB.DatabaseWriter, completion: @escaping (GRDB.Database, (any Swift.Error)?) -> Swift.Void)
}
extension GRDB.DatabaseRegionObservation {
  @available(*, unavailable, message: "The extent of the observation is now controlled by the cancellable returned by DatabaseRegionObservation.start().")
  public var extent: GRDB.Database.TransactionObservationExtent {
    get
    set
  }
}
extension GRDB.DatabaseUUIDEncodingStrategy {
  @available(*, unavailable, renamed: "uppercaseString")
  public static var string: GRDB.DatabaseUUIDEncodingStrategy {
    get
  }
}
extension GRDB.MutablePersistableRecord {
  @available(*, unavailable, message: "Use persistence callbacks instead.")
  public mutating func performInsert(_ db: GRDB.Database) throws
  @available(*, unavailable, message: "Use persistence callbacks instead.")
  public func performUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>) throws
  @available(*, unavailable, message: "Use persistence callbacks instead.")
  public mutating func performSave(_ db: GRDB.Database) throws
  @available(*, unavailable, message: "Use persistence callbacks instead.")
  public func performDelete(_ db: GRDB.Database) throws -> Swift.Bool
  @available(*, unavailable, message: "performExists(_:) was removed without any replacement.")
  public func performExists(_ db: GRDB.Database) throws -> Swift.Bool
  @available(*, unavailable, renamed: "updateChanges(_:modify:)")
  public mutating func updateChanges(_ db: GRDB.Database, with change: (inout Self) throws -> Swift.Void) throws -> Swift.Bool
}
extension GRDB.PersistableRecord {
  @available(*, unavailable, message: "Use persistence callbacks instead.")
  public func performInsert(_ db: GRDB.Database) throws
  @available(*, unavailable, message: "Use persistence callbacks instead.")
  public func performSave(_ db: GRDB.Database) throws
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.QueryInterfaceRequest where RowDecoder : Swift.Identifiable, RowDecoder.ID : GRDB.DatabaseValueConvertible {
  @available(*, unavailable, message: "selectID() has been removed. You may use selectPrimaryKey(as:) instead.")
  public func selectID() -> GRDB.QueryInterfaceRequest<RowDecoder.ID>
}
@available(*, unavailable, renamed: "Statement")
public typealias SelectStatement = GRDB.Statement
@available(*, unavailable, renamed: "SQLExpression.AssociativeBinaryOperator")
public typealias SQLAssociativeBinaryOperator = GRDB.SQLExpression.AssociativeBinaryOperator
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.Table where RowDecoder : Swift.Identifiable, RowDecoder.ID : GRDB.DatabaseValueConvertible {
  @available(*, unavailable, message: "selectID() has been removed. You may use selectPrimaryKey(as:) instead.")
  public func selectID() -> GRDB.QueryInterfaceRequest<RowDecoder.ID>
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.TableRecord where Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  @available(*, unavailable, message: "selectID() has been removed. You may use selectPrimaryKey(as:) instead.")
  public static func selectID() -> GRDB.QueryInterfaceRequest<Self.ID>
}
@available(*, unavailable, renamed: "Statement")
public typealias UpdateStatement = GRDB.Statement
extension GRDB.ValueObservation {
  @available(*, unavailable, renamed: "tracking(_:)")
  public static func trackingVaryingRegion<Value>(_ fetch: @escaping (GRDB.Database) throws -> Value) -> GRDB.ValueObservation<Reducer> where Reducer == GRDB.ValueReducers.Fetch<Value>
}
public struct Inflections {
  public init()
  public mutating func plural(_ pattern: Swift.String, options: Foundation.NSRegularExpression.Options = [.caseInsensitive], _ template: Swift.String)
  public mutating func singular(_ pattern: Swift.String, options: Foundation.NSRegularExpression.Options = [.caseInsensitive], _ template: Swift.String)
  public mutating func uncountableWords(_ words: [Swift.String])
  public mutating func irregularSuffix(_ singular: Swift.String, _ plural: Swift.String)
  public func pluralize(_ string: Swift.String) -> Swift.String
  public func singularize(_ string: Swift.String) -> Swift.String
}
extension GRDB.Database {
  final public func makeStatement(sql: Swift.String) throws -> GRDB.Statement
  final public func makeStatement(literal sqlLiteral: GRDB.SQL) throws -> GRDB.Statement
  final public func cachedStatement(sql: Swift.String) throws -> GRDB.Statement
  final public func cachedStatement(literal sqlLiteral: GRDB.SQL) throws -> GRDB.Statement
  final public func allStatements(sql: Swift.String, arguments: GRDB.StatementArguments? = nil) throws -> GRDB.SQLStatementCursor
  final public func allStatements(literal sqlLiteral: GRDB.SQL) throws -> GRDB.SQLStatementCursor
  final public func execute(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) throws
  final public func execute(literal sqlLiteral: GRDB.SQL) throws
}
@_hasMissingDesignatedInitializers public class SQLStatementCursor {
  @objc deinit
}
extension GRDB.SQLStatementCursor : GRDB.Cursor {
  public func next() throws -> GRDB.Statement?
  public typealias Element = GRDB.Statement
}
extension GRDB.Database {
  @usableFromInline
  final internal func statementWillExecute(_ statement: GRDB.Statement) throws
  @usableFromInline
  final internal func statementDidExecute(_ statement: GRDB.Statement) throws
  @usableFromInline
  final internal func statementDidFail(_ statement: GRDB.Statement, withResultCode resultCode: Swift.CInt) throws -> Swift.Never
}
extension GRDB.Database {
  final public func schemaVersion() throws -> Swift.Int32
  final public func clearSchemaCache()
  final public func tableExists(_ name: Swift.String) throws -> Swift.Bool
  public static func isSQLiteInternalTable(_ tableName: Swift.String) -> Swift.Bool
  public static func isGRDBInternalTable(_ tableName: Swift.String) -> Swift.Bool
  final public func viewExists(_ name: Swift.String) throws -> Swift.Bool
  final public func triggerExists(_ name: Swift.String) throws -> Swift.Bool
  final public func primaryKey(_ tableName: Swift.String) throws -> GRDB.PrimaryKeyInfo
  final public func indexes(on tableName: Swift.String) throws -> [GRDB.IndexInfo]
  final public func table<Columns>(_ tableName: Swift.String, hasUniqueKey columns: Columns) throws -> Swift.Bool where Columns : Swift.Sequence, Columns.Element == Swift.String
  final public func foreignKeys(on tableName: Swift.String) throws -> [GRDB.ForeignKeyInfo]
  final public func foreignKeyViolations() throws -> GRDB.RecordCursor<GRDB.ForeignKeyViolation>
  final public func foreignKeyViolations(in tableName: Swift.String) throws -> GRDB.RecordCursor<GRDB.ForeignKeyViolation>
  final public func checkForeignKeys() throws
  final public func checkForeignKeys(in tableName: Swift.String) throws
}
extension GRDB.Database {
  final public func columns(in tableName: Swift.String) throws -> [GRDB.ColumnInfo]
}
public struct ColumnInfo : GRDB.FetchableRecord {
  public let name: Swift.String
  public let type: Swift.String
  public let isNotNull: Swift.Bool
  public let defaultValueSQL: Swift.String?
  public let primaryKeyIndex: Swift.Int
  public init(row: GRDB.Row)
}
public struct IndexInfo {
  public struct Origin : Swift.RawRepresentable, Swift.Equatable, GRDB.DatabaseValueConvertible {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public static let createIndex: GRDB.IndexInfo.Origin
    public static let uniqueConstraint: GRDB.IndexInfo.Origin
    public static let primaryKeyConstraint: GRDB.IndexInfo.Origin
    public typealias RawValue = Swift.String
  }
  public let name: Swift.String
  public let columns: [Swift.String]
  public let isUnique: Swift.Bool
  public let origin: GRDB.IndexInfo.Origin
}
public struct ForeignKeyViolation {
  public var originTable: Swift.String
  public var originRowID: Swift.Int64?
  public var destinationTable: Swift.String
  public var foreignKeyId: Swift.Int
  public func failureDescription(_ db: GRDB.Database) throws -> Swift.String
  public func databaseError(_ db: GRDB.Database) -> GRDB.DatabaseError
}
extension GRDB.ForeignKeyViolation : GRDB.FetchableRecord {
  public init(row: GRDB.Row)
}
extension GRDB.ForeignKeyViolation : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct PrimaryKeyInfo {
  public var columns: [Swift.String] {
    get
  }
  public var rowIDColumn: Swift.String? {
    get
  }
  public var isRowID: Swift.Bool {
    get
  }
}
public struct ForeignKeyInfo {
  public var id: Swift.Int
  public let destinationTable: Swift.String
  public let mapping: [(origin: Swift.String, destination: Swift.String)]
  public var originColumns: [Swift.String] {
    get
  }
  public var destinationColumns: [Swift.String] {
    get
  }
}
public struct CommonTableExpression<RowDecoder> {
  public var tableName: Swift.String {
    get
  }
}
extension GRDB.CommonTableExpression {
  public init(recursive: Swift.Bool = false, named tableName: Swift.String, columns: [Swift.String]? = nil, request: some SQLSubqueryable)
  public init(recursive: Swift.Bool = false, named tableName: Swift.String, columns: [Swift.String]? = nil, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments())
  public init(recursive: Swift.Bool = false, named tableName: Swift.String, columns: [Swift.String]? = nil, literal sqlLiteral: GRDB.SQL)
}
extension GRDB.CommonTableExpression where RowDecoder == GRDB.Row {
  public init(recursive: Swift.Bool = false, named tableName: Swift.String, columns: [Swift.String]? = nil, request: some SQLSubqueryable)
  public init(recursive: Swift.Bool = false, named tableName: Swift.String, columns: [Swift.String]? = nil, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments())
  public init(recursive: Swift.Bool = false, named tableName: Swift.String, columns: [Swift.String]? = nil, literal sqlLiteral: GRDB.SQL)
}
extension GRDB.CommonTableExpression {
  public func all() -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func contains(_ element: some SQLExpressible) -> GRDB.SQLExpression
}
extension GRDB.CommonTableExpression {
  public func association<Destination>(to cte: GRDB.CommonTableExpression<Destination>, on condition: @escaping (_ left: GRDB.TableAlias, _ right: GRDB.TableAlias) -> any GRDB.SQLExpressible) -> GRDB.JoinAssociation<RowDecoder, Destination>
  public func association<Destination>(to cte: GRDB.CommonTableExpression<Destination>) -> GRDB.JoinAssociation<RowDecoder, Destination>
  public func association<Destination>(to destination: Destination.Type, on condition: @escaping (_ left: GRDB.TableAlias, _ right: GRDB.TableAlias) -> any GRDB.SQLExpressible) -> GRDB.JoinAssociation<RowDecoder, Destination> where Destination : GRDB.TableRecord
  public func association<Destination>(to destination: Destination.Type) -> GRDB.JoinAssociation<RowDecoder, Destination> where Destination : GRDB.TableRecord
  public func association<Destination>(to destination: GRDB.Table<Destination>, on condition: @escaping (_ left: GRDB.TableAlias, _ right: GRDB.TableAlias) -> any GRDB.SQLExpressible) -> GRDB.JoinAssociation<RowDecoder, Destination>
  public func association<Destination>(to destination: GRDB.Table<Destination>) -> GRDB.JoinAssociation<RowDecoder, Destination>
}
public struct Table<RowDecoder> {
  public var tableName: Swift.String
  public init(_ tableName: Swift.String)
}
extension GRDB.Table where RowDecoder == GRDB.Row {
  public init(_ tableName: Swift.String)
}
extension GRDB.Table : GRDB.DatabaseRegionConvertible {
  public func databaseRegion(_ db: GRDB.Database) throws -> GRDB.DatabaseRegion
}
extension GRDB.Table {
  public func all() -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func none() -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func select(_ selection: any GRDB.SQLSelectable...) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func select(_ selection: [any GRDB.SQLSelectable]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func select(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func select(literal sqlLiteral: GRDB.SQL) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func select<T>(_ selection: [any GRDB.SQLSelectable], as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func select<T>(_ selection: any GRDB.SQLSelectable..., as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func select<T>(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func select<T>(literal sqlLiteral: GRDB.SQL, as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func selectPrimaryKey<PrimaryKey>(as type: PrimaryKey.Type = PrimaryKey.self) -> GRDB.QueryInterfaceRequest<PrimaryKey>
  public func annotated(with selection: [any GRDB.SQLSelectable]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func annotated(with selection: any GRDB.SQLSelectable...) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter(_ predicate: some SQLSpecificExpressible) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter(key: some DatabaseValueConvertible) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter<Keys>(keys: Keys) -> GRDB.QueryInterfaceRequest<RowDecoder> where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
  public func filter(key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]?) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter(keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter(literal sqlLiteral: GRDB.SQL) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func order(_ orderings: any GRDB.SQLOrderingTerm...) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func order(_ orderings: [any GRDB.SQLOrderingTerm]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func orderByPrimaryKey() -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func order(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments()) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func order(literal sqlLiteral: GRDB.SQL) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func aliased(_ alias: GRDB.TableAlias) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func with<T>(_ cte: GRDB.CommonTableExpression<T>) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.Table where RowDecoder : Swift.Identifiable, RowDecoder.ID : GRDB.DatabaseValueConvertible {
  public func filter(id: RowDecoder.ID) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func filter<IDS>(ids: IDS) -> GRDB.QueryInterfaceRequest<RowDecoder> where IDS : Swift.Collection, RowDecoder.ID == IDS.Element
}
extension GRDB.Table {
  public func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
}
extension GRDB.Table where RowDecoder : GRDB.FetchableRecord {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.RecordCursor<RowDecoder>
  public func fetchAll(_ db: GRDB.Database) throws -> [RowDecoder]
  public func fetchOne(_ db: GRDB.Database) throws -> RowDecoder?
}
extension GRDB.Table where RowDecoder : GRDB.FetchableRecord, RowDecoder : Swift.Hashable {
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<RowDecoder>
}
extension GRDB.Table where RowDecoder == GRDB.Row {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.RowCursor
  public func fetchAll(_ db: GRDB.Database) throws -> [GRDB.Row]
  public func fetchOne(_ db: GRDB.Database) throws -> GRDB.Row?
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<GRDB.Row>
}
extension GRDB.Table where RowDecoder : GRDB.DatabaseValueConvertible {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.DatabaseValueCursor<RowDecoder>
  public func fetchAll(_ db: GRDB.Database) throws -> [RowDecoder]
  public func fetchOne(_ db: GRDB.Database) throws -> RowDecoder?
}
extension GRDB.Table where RowDecoder : GRDB.DatabaseValueConvertible, RowDecoder : Swift.Hashable {
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<RowDecoder>
}
extension GRDB.Table where RowDecoder : GRDB.DatabaseValueConvertible, RowDecoder : GRDB.StatementColumnConvertible {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.FastDatabaseValueCursor<RowDecoder>
  public func fetchAll(_ db: GRDB.Database) throws -> [RowDecoder]
  public func fetchOne(_ db: GRDB.Database) throws -> RowDecoder?
}
extension GRDB.Table where RowDecoder : GRDB.DatabaseValueConvertible, RowDecoder : GRDB.StatementColumnConvertible, RowDecoder : Swift.Hashable {
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<RowDecoder>
}
extension GRDB.Table {
  public func belongsTo<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.BelongsToAssociation<RowDecoder, Destination> where Destination : GRDB.TableRecord
  public func hasMany<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasManyAssociation<RowDecoder, Destination> where Destination : GRDB.TableRecord
  public func hasOne<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasOneAssociation<RowDecoder, Destination> where Destination : GRDB.TableRecord
}
extension GRDB.Table {
  public func belongsTo<Destination>(_ destination: GRDB.Table<Destination>, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.BelongsToAssociation<RowDecoder, Destination>
  public func hasMany<Destination>(_ destination: GRDB.Table<Destination>, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasManyAssociation<RowDecoder, Destination>
  public func hasOne<Destination>(_ destination: GRDB.Table<Destination>, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasOneAssociation<RowDecoder, Destination>
}
extension GRDB.Table {
  public func association<Destination>(to cte: GRDB.CommonTableExpression<Destination>, on condition: @escaping (_ left: GRDB.TableAlias, _ right: GRDB.TableAlias) -> any GRDB.SQLExpressible) -> GRDB.JoinAssociation<RowDecoder, Destination>
  public func association<Destination>(to cte: GRDB.CommonTableExpression<Destination>) -> GRDB.JoinAssociation<RowDecoder, Destination>
}
extension GRDB.Table {
  public func hasMany<Pivot, Target>(_ destination: Target.RowDecoder.Type, through pivot: Pivot, using target: Target, key: Swift.String? = nil) -> GRDB.HasManyThroughAssociation<RowDecoder, Target.RowDecoder> where RowDecoder == Pivot.OriginRowDecoder, Pivot : GRDB.Association, Target : GRDB.Association, Pivot.RowDecoder == Target.OriginRowDecoder
  public func hasOne<Pivot, Target>(_ destination: Target.RowDecoder.Type, through pivot: Pivot, using target: Target, key: Swift.String? = nil) -> GRDB.HasOneThroughAssociation<RowDecoder, Target.RowDecoder> where RowDecoder == Pivot.OriginRowDecoder, Pivot : GRDB.AssociationToOne, Target : GRDB.AssociationToOne, Pivot.RowDecoder == Target.OriginRowDecoder
}
extension GRDB.Table {
  public func including<A>(all association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.AssociationToMany
  public func including<A>(optional association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.Association
  public func including<A>(required association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.Association
  public func joining<A>(optional association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.Association
  public func joining<A>(required association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.Association
  public func annotated<A>(withOptional association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.Association
  public func annotated<A>(withRequired association: A) -> GRDB.QueryInterfaceRequest<RowDecoder> where RowDecoder == A.OriginRowDecoder, A : GRDB.Association
}
extension GRDB.Table {
  public func annotated(with aggregates: GRDB.AssociationAggregate<RowDecoder>...) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func annotated(with aggregates: [GRDB.AssociationAggregate<RowDecoder>]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func having(_ predicate: GRDB.AssociationAggregate<RowDecoder>) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.Table {
  @discardableResult
  public func deleteAll(_ db: GRDB.Database) throws -> Swift.Int
}
extension GRDB.Table {
  public func exists(_ db: GRDB.Database, key: some DatabaseValueConvertible) throws -> Swift.Bool
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.Table where RowDecoder : Swift.Identifiable, RowDecoder.ID : GRDB.DatabaseValueConvertible {
  public func exists(_ db: GRDB.Database, id: RowDecoder.ID) throws -> Swift.Bool
}
extension GRDB.Table {
  public func exists(_ db: GRDB.Database, key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]) throws -> Swift.Bool
}
extension GRDB.Table {
  @discardableResult
  public func deleteAll<Keys>(_ db: GRDB.Database, keys: Keys) throws -> Swift.Int where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
  @discardableResult
  public func deleteOne(_ db: GRDB.Database, key: some DatabaseValueConvertible) throws -> Swift.Bool
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.Table where RowDecoder : Swift.Identifiable, RowDecoder.ID : GRDB.DatabaseValueConvertible {
  @discardableResult
  public func deleteAll<IDS>(_ db: GRDB.Database, ids: IDS) throws -> Swift.Int where IDS : Swift.Collection, RowDecoder.ID == IDS.Element
  @discardableResult
  public func deleteOne(_ db: GRDB.Database, id: RowDecoder.ID) throws -> Swift.Bool
}
extension GRDB.Table {
  @discardableResult
  public func deleteAll(_ db: GRDB.Database, keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) throws -> Swift.Int
  @discardableResult
  public func deleteOne(_ db: GRDB.Database, key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]) throws -> Swift.Bool
}
extension GRDB.Table {
  @discardableResult
  public func updateAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment]) throws -> Swift.Int
  @discardableResult
  public func updateAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: GRDB.ColumnAssignment...) throws -> Swift.Int
}
public struct ValueObservation<Reducer> where Reducer : GRDB._ValueReducer {
  public var requiresWriteAccess: Swift.Bool
}
extension GRDB.ValueObservation {
  public func start(in reader: some DatabaseReader, scheduling scheduler: some ValueObservationScheduler = .async(onQueue: .main), onError: @escaping (any Swift.Error) -> Swift.Void, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
  public func handleEvents(willStart: (() -> Swift.Void)? = nil, willFetch: (() -> Swift.Void)? = nil, willTrackRegion: ((GRDB.DatabaseRegion) -> Swift.Void)? = nil, databaseDidChange: (() -> Swift.Void)? = nil, didReceiveValue: ((Reducer.Value) -> Swift.Void)? = nil, didFail: ((any Swift.Error) -> Swift.Void)? = nil, didCancel: (() -> Swift.Void)? = nil) -> GRDB.ValueObservation<GRDB.ValueReducers.Trace<Reducer>>
  public func print(_ prefix: Swift.String = "", to stream: (any Swift.TextOutputStream)? = nil) -> GRDB.ValueObservation<GRDB.ValueReducers.Trace<Reducer>>
}
extension GRDB.ValueObservation {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func values(in reader: some DatabaseReader, scheduling scheduler: some ValueObservationScheduler = .async(onQueue: .main), bufferingPolicy: GRDB.AsyncValueObservation<Reducer.Value>.BufferingPolicy = .unbounded) -> GRDB.AsyncValueObservation<Reducer.Value> where Reducer : GRDB.ValueReducer
  #endif
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
public struct AsyncValueObservation<Element> : _Concurrency.AsyncSequence {
  public typealias BufferingPolicy = _Concurrency.AsyncThrowingStream<Element, any Swift.Error>.Continuation.BufferingPolicy
  public typealias AsyncIterator = GRDB.AsyncValueObservation<Element>.Iterator
  public func makeAsyncIterator() -> GRDB.AsyncValueObservation<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async throws -> Element?
    #endif
  }
}
#endif
extension GRDB.ValueObservation {
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func publisher(in reader: some DatabaseReader, scheduling scheduler: some ValueObservationScheduler = .async(onQueue: .main)) -> GRDB.DatabasePublishers.Value<Reducer.Value> where Reducer : GRDB.ValueReducer
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.DatabasePublishers {
  public struct Value<Output> : Combine.Publisher {
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == any Swift.Error
  }
}
extension GRDB.ValueObservation {
  public static func trackingConstantRegion<Value>(_ fetch: @escaping (GRDB.Database) throws -> Value) -> GRDB.ValueObservation<Reducer> where Reducer == GRDB.ValueReducers.Fetch<Value>
  public static func tracking<Value>(region: any GRDB.DatabaseRegionConvertible, _ otherRegions: any GRDB.DatabaseRegionConvertible..., fetch: @escaping (GRDB.Database) throws -> Value) -> GRDB.ValueObservation<Reducer> where Reducer == GRDB.ValueReducers.Fetch<Value>
  public static func tracking<Value>(regions: [any GRDB.DatabaseRegionConvertible], fetch: @escaping (GRDB.Database) throws -> Value) -> GRDB.ValueObservation<Reducer> where Reducer == GRDB.ValueReducers.Fetch<Value>
  public static func tracking<Value>(_ fetch: @escaping (GRDB.Database) throws -> Value) -> GRDB.ValueObservation<Reducer> where Reducer == GRDB.ValueReducers.Fetch<Value>
}
extension GRDB.TableRequest where Self : GRDB.FilteredRequest {
  public func matching(_ pattern: GRDB.FTS3Pattern?) -> Self
}
extension GRDB.TableRecord {
  public static func matching(_ pattern: GRDB.FTS3Pattern?) -> GRDB.QueryInterfaceRequest<Self>
}
extension GRDB.ColumnExpression {
  public func match(_ pattern: GRDB.FTS3Pattern?) -> GRDB.SQLExpression
}
@_hasMissingDesignatedInitializers final public class DatabaseSnapshot {
  final public var configuration: GRDB.Configuration {
    get
  }
  final public var path: Swift.String {
    get
  }
  @objc deinit
}
extension GRDB.DatabaseSnapshot : GRDB.DatabaseSnapshotReader {
  final public func close() throws
  final public func interrupt()
  final public func read<T>(_ block: (GRDB.Database) throws -> T) rethrows -> T
  final public func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) rethrows -> T
  final public func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
public struct DatabaseRegion {
  public var isEmpty: Swift.Bool {
    get
  }
  public var isFullDatabase: Swift.Bool {
    get
  }
  public static let fullDatabase: GRDB.DatabaseRegion
  public init()
  public func union(_ other: GRDB.DatabaseRegion) -> GRDB.DatabaseRegion
  public mutating func formUnion(_ other: GRDB.DatabaseRegion)
}
extension GRDB.DatabaseRegion {
  public func isModified(byEventsOfKind eventKind: GRDB.DatabaseEventKind) -> Swift.Bool
  public func isModified(by event: GRDB.DatabaseEvent) -> Swift.Bool
}
extension GRDB.DatabaseRegion : Swift.Equatable {
  public static func == (lhs: GRDB.DatabaseRegion, rhs: GRDB.DatabaseRegion) -> Swift.Bool
}
extension GRDB.DatabaseRegion : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol DatabaseRegionConvertible {
  func databaseRegion(_ db: GRDB.Database) throws -> GRDB.DatabaseRegion
}
extension GRDB.DatabaseRegionConvertible where Self == GRDB.DatabaseRegion {
  public static var fullDatabase: GRDB.DatabaseRegion {
    get
  }
}
extension GRDB.DatabaseRegion : GRDB.DatabaseRegionConvertible {
  public func databaseRegion(_ db: GRDB.Database) throws -> GRDB.DatabaseRegion
}
public struct AnyDatabaseRegionConvertible : GRDB.DatabaseRegionConvertible {
  public init(_ region: @escaping (GRDB.Database) throws -> GRDB.DatabaseRegion)
  public init(_ region: some DatabaseRegionConvertible)
  public func databaseRegion(_ db: GRDB.Database) throws -> GRDB.DatabaseRegion
}
public protocol FetchableRecord {
  init(row: GRDB.Row) throws
  static var databaseDecodingUserInfo: [Swift.CodingUserInfoKey : Any] { get }
  static func databaseJSONDecoder(for column: Swift.String) -> Foundation.JSONDecoder
  static var databaseDateDecodingStrategy: GRDB.DatabaseDateDecodingStrategy { get }
  static var databaseColumnDecodingStrategy: GRDB.DatabaseColumnDecodingStrategy { get }
}
extension GRDB.FetchableRecord {
  public static var databaseDecodingUserInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public static func databaseJSONDecoder(for column: Swift.String) -> Foundation.JSONDecoder
  public static var databaseDateDecodingStrategy: GRDB.DatabaseDateDecodingStrategy {
    get
  }
  public static var databaseColumnDecodingStrategy: GRDB.DatabaseColumnDecodingStrategy {
    get
  }
}
extension GRDB.FetchableRecord {
  public static func fetchCursor(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.RecordCursor<Self>
  public static func fetchAll(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Self?
}
extension GRDB.FetchableRecord where Self : Swift.Hashable {
  public static func fetchSet(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<Self>
}
extension GRDB.FetchableRecord {
  public static func fetchCursor(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.RecordCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Self?
}
extension GRDB.FetchableRecord where Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<Self>
}
extension GRDB.FetchableRecord {
  public static func fetchCursor(_ db: GRDB.Database, _ request: some FetchRequest) throws -> GRDB.RecordCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, _ request: some FetchRequest) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Self?
}
extension GRDB.FetchableRecord where Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Swift.Set<Self>
}
extension GRDB.FetchRequest where Self.RowDecoder : GRDB.FetchableRecord {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.RecordCursor<Self.RowDecoder>
  public func fetchAll(_ db: GRDB.Database) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: GRDB.Database) throws -> Self.RowDecoder?
}
extension GRDB.FetchRequest where Self.RowDecoder : GRDB.FetchableRecord, Self.RowDecoder : Swift.Hashable {
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<Self.RowDecoder>
}
@_hasMissingDesignatedInitializers final public class RecordCursor<Record> : GRDB.DatabaseCursor where Record : GRDB.FetchableRecord {
  public typealias Element = Record
  final public let _statement: GRDB.Statement
  final public var _isDone: Swift.Bool
  @usableFromInline
  final internal let _row: GRDB.Row
  @objc deinit
  @inlinable final public func _element(sqliteStatement: GRDB.SQLiteStatement) throws -> Record {
        try Record(row: _row)
    }
}
public enum DatabaseDateDecodingStrategy {
  case deferredToDate
  case timeIntervalSinceReferenceDate
  case timeIntervalSince1970
  case millisecondsSince1970
  case iso8601
  case formatted(Foundation.DateFormatter)
  case custom((GRDB.DatabaseValue) -> Foundation.Date?)
}
public enum DatabaseColumnDecodingStrategy {
  case useDefaultKeys
  case convertFromSnakeCase
  case custom((Swift.String) -> any Swift.CodingKey)
}
public struct QueryInterfaceRequest<RowDecoder> {
}
extension GRDB.QueryInterfaceRequest : GRDB.FetchRequest {
  public var sqlSubquery: GRDB.SQLSubquery {
    get
  }
  public func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
  public func makePreparedRequest(_ db: GRDB.Database, forSingleResult singleResult: Swift.Bool = false) throws -> GRDB.PreparedRequest
}
extension GRDB.QueryInterfaceRequest : GRDB.SelectionRequest {
  public func selectWhenConnected(_ selection: @escaping (GRDB.Database) throws -> [any GRDB.SQLSelectable]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func select<T>(_ selection: [any GRDB.SQLSelectable], as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func select<T>(_ selection: any GRDB.SQLSelectable..., as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func select<T>(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func select<T>(literal sqlLiteral: GRDB.SQL, as type: T.Type = T.self) -> GRDB.QueryInterfaceRequest<T>
  public func selectPrimaryKey<PrimaryKey>(as type: PrimaryKey.Type = PrimaryKey.self) -> GRDB.QueryInterfaceRequest<PrimaryKey>
  public func annotatedWhenConnected(with selection: @escaping (GRDB.Database) throws -> [any GRDB.SQLSelectable]) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest : GRDB.FilteredRequest {
  public func filterWhenConnected(_ predicate: @escaping (GRDB.Database) throws -> any GRDB.SQLExpressible) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest : GRDB.OrderedRequest {
  public func orderWhenConnected(_ orderings: @escaping (GRDB.Database) throws -> [any GRDB.SQLOrderingTerm]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func reversed() -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func unordered() -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest : GRDB.AggregatingRequest {
  public func groupWhenConnected(_ expressions: @escaping (GRDB.Database) throws -> [any GRDB.SQLExpressible]) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func havingWhenConnected(_ predicate: @escaping (GRDB.Database) throws -> any GRDB.SQLExpressible) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest : GRDB.JoinableRequest {
  public func _including(all association: GRDB._SQLAssociation) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func _including(optional association: GRDB._SQLAssociation) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func _including(required association: GRDB._SQLAssociation) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func _joining(optional association: GRDB._SQLAssociation) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func _joining(required association: GRDB._SQLAssociation) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest : GRDB.TableRequest {
  public var databaseTableName: Swift.String {
    get
  }
  public func aliased(_ alias: GRDB.TableAlias) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest : GRDB.DerivableRequest {
  public func distinct() -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> GRDB.QueryInterfaceRequest<RowDecoder>
  public func with<T>(_ cte: GRDB.CommonTableExpression<T>) -> GRDB.QueryInterfaceRequest<RowDecoder>
}
extension GRDB.QueryInterfaceRequest {
  public func asRequest<T>(of type: T.Type) -> GRDB.QueryInterfaceRequest<T>
}
extension GRDB.QueryInterfaceRequest {
  public func isEmpty(_ db: GRDB.Database) throws -> Swift.Bool
}
extension GRDB.QueryInterfaceRequest {
  @discardableResult
  public func deleteAll(_ db: GRDB.Database) throws -> Swift.Int
}
extension GRDB.QueryInterfaceRequest {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func deleteAndFetchStatement(_ db: GRDB.Database, selection: [any GRDB.SQLSelectable]) throws -> GRDB.Statement
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func deleteAndFetchCursor(_ db: GRDB.Database) throws -> GRDB.RecordCursor<RowDecoder> where RowDecoder : GRDB.FetchableRecord, RowDecoder : GRDB.TableRecord
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func deleteAndFetchAll(_ db: GRDB.Database) throws -> [RowDecoder] where RowDecoder : GRDB.FetchableRecord, RowDecoder : GRDB.TableRecord
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func deleteAndFetchSet(_ db: GRDB.Database) throws -> Swift.Set<RowDecoder> where RowDecoder : GRDB.FetchableRecord, RowDecoder : GRDB.TableRecord, RowDecoder : Swift.Hashable
}
extension GRDB.QueryInterfaceRequest {
  @discardableResult
  public func updateAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment]) throws -> Swift.Int
  @discardableResult
  public func updateAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: GRDB.ColumnAssignment...) throws -> Swift.Int
}
extension GRDB.QueryInterfaceRequest {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func updateAndFetchStatement(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment], selection: [any GRDB.SQLSelectable]) throws -> GRDB.Statement
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func updateAndFetchCursor(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment]) throws -> GRDB.RecordCursor<RowDecoder> where RowDecoder : GRDB.FetchableRecord, RowDecoder : GRDB.TableRecord
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func updateAndFetchAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment]) throws -> [RowDecoder] where RowDecoder : GRDB.FetchableRecord, RowDecoder : GRDB.TableRecord
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  public func updateAndFetchSet(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment]) throws -> Swift.Set<RowDecoder> where RowDecoder : GRDB.FetchableRecord, RowDecoder : GRDB.TableRecord, RowDecoder : Swift.Hashable
}
public struct ColumnAssignment {
}
extension GRDB.ColumnExpression {
  public func set(to value: (any GRDB.SQLExpressible)?) -> GRDB.ColumnAssignment
  public var noOverwrite: GRDB.ColumnAssignment {
    get
  }
}
extension GRDB.ColumnExpression {
  public static func += (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func -= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func *= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func /= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func &= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func |= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func <<= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
  public static func >>= (column: Self, value: some SQLExpressible) -> GRDB.ColumnAssignment
}
extension GRDB.PersistableRecord {
  @inline(__always) @inlinable public func willInsert(_ db: GRDB.Database) throws { }
  @inline(__always) @inlinable public func didInsert(_ inserted: GRDB.InsertionSuccess) { }
}
extension GRDB.PersistableRecord {
  @inlinable public func insert(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws {
        try willSave(db)
        
        var saved: PersistenceSuccess?
        try aroundSave(db) {
            let inserted = try insertWithCallbacks(db, onConflict: conflictResolution)
            saved = PersistenceSuccess(inserted)
            return saved!
        }
        
        guard let saved else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(saved)
    }
}
extension GRDB.PersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func insertAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, as returnedType: T.Type) throws -> T? where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try insertAndFetch(db, onConflict: conflictResolution, selection: T.databaseSelection) {
            try T.fetchOne($0)
        }
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func insertAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T {
        GRDBPrecondition(!selection.isEmpty, "Invalid empty selection")
        
        try willSave(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundSave(db) {
            success = try insertAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                selection: selection,
                fetch: fetch)
            return PersistenceSuccess(success!.inserted)
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(PersistenceSuccess(success.inserted))
        return success.returned
    }
}
extension GRDB.PersistableRecord {
  @inlinable internal func insertWithCallbacks(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?) throws -> GRDB.InsertionSuccess {
        let (inserted, _) = try insertAndFetchWithCallbacks(db, onConflict: conflictResolution, selection: []) {
            // Nothing to fetch
            try $0.execute()
        }
        return inserted
    }
  @inlinable internal func insertAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.InsertionSuccess, T) {
        try willInsert(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundInsert(db) {
            success = try insertAndFetchWithoutCallbacks(
                db, onConflict: conflictResolution,
                selection: selection,
                fetch: fetch)
            return success!.inserted
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundInsert")
        }
        didInsert(success.inserted)
        return success
    }
}
public struct SQLSelection {
}
public protocol SQLSelectable {
  var sqlSelection: GRDB.SQLSelection { get }
}
extension GRDB.SQLSelection : GRDB.SQLSelectable {
  @available(*, deprecated, message: "Already SQLSelection")
  public var sqlSelection: GRDB.SQLSelection {
    get
  }
}
public struct AllColumns {
  public init()
}
extension GRDB.AllColumns : GRDB.SQLSelectable {
  public var sqlSelection: GRDB.SQLSelection {
    get
  }
}
extension GRDB.ValueReducers {
  public struct Fetch<Value> : GRDB.ValueReducer {
    public func _fetch(_ db: GRDB.Database) throws -> Value
    public func _value(_ fetched: Value) -> Value?
    public typealias Fetched = Value
  }
}
extension GRDB.Database {
  final public func add(transactionObserver: some TransactionObserver, extent: GRDB.Database.TransactionObservationExtent = .observerLifetime)
  final public func remove(transactionObserver: some TransactionObserver)
  final public func afterNextTransaction(onCommit: @escaping (GRDB.Database) -> Swift.Void, onRollback: @escaping (GRDB.Database) -> Swift.Void = { _ in })
  public enum TransactionObservationExtent {
    case observerLifetime
    case nextTransaction
    case databaseLifetime
    public static func == (a: GRDB.Database.TransactionObservationExtent, b: GRDB.Database.TransactionObservationExtent) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol TransactionObserver : AnyObject {
  func observes(eventsOfKind eventKind: GRDB.DatabaseEventKind) -> Swift.Bool
  func databaseDidChange(with event: GRDB.DatabaseEvent)
  func databaseWillCommit() throws
  func databaseDidCommit(_ db: GRDB.Database)
  func databaseDidRollback(_ db: GRDB.Database)
  func databaseWillChange(with event: GRDB.DatabasePreUpdateEvent)
}
extension GRDB.TransactionObserver {
  public func databaseWillCommit() throws
  public func databaseWillChange(with event: GRDB.DatabasePreUpdateEvent)
  public func stopObservingDatabaseChangesUntilNextTransaction()
}
@frozen public enum DatabaseEventKind {
  case insert(tableName: Swift.String)
  case delete(tableName: Swift.String)
  case update(tableName: Swift.String, columnNames: Swift.Set<Swift.String>)
}
extension GRDB.DatabaseEventKind {
  public var tableName: Swift.String {
    get
  }
}
public struct DatabaseEvent {
  public enum Kind : Swift.CInt {
    case insert
    case delete
    case update
    public init?(rawValue: Swift.CInt)
    public typealias RawValue = Swift.CInt
    public var rawValue: Swift.CInt {
      get
    }
  }
  public let kind: GRDB.DatabaseEvent.Kind
  public var databaseName: Swift.String {
    get
  }
  public var tableName: Swift.String {
    get
  }
  public let rowID: Swift.Int64
  public func copy() -> GRDB.DatabaseEvent
}
public struct DatabasePreUpdateEvent {
  public enum Kind : Swift.CInt {
    case insert
    case delete
    case update
    public init?(rawValue: Swift.CInt)
    public typealias RawValue = Swift.CInt
    public var rawValue: Swift.CInt {
      get
    }
  }
  public let kind: GRDB.DatabasePreUpdateEvent.Kind
  public var databaseName: Swift.String {
    get
  }
  public var tableName: Swift.String {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var depth: Swift.CInt {
    get
  }
  public let initialRowID: Swift.Int64?
  public let finalRowID: Swift.Int64?
  public var initialDatabaseValues: [GRDB.DatabaseValue]? {
    get
  }
  public func initialDatabaseValue(atIndex index: Swift.Int) -> GRDB.DatabaseValue?
  public var finalDatabaseValues: [GRDB.DatabaseValue]? {
    get
  }
  public func finalDatabaseValue(atIndex index: Swift.Int) -> GRDB.DatabaseValue?
  public func copy() -> GRDB.DatabasePreUpdateEvent
}
extension GRDB.SQLSpecificExpressible {
  public static func == (lhs: Self, rhs: (any GRDB.SQLExpressible)?) -> GRDB.SQLExpression
  public static func == (lhs: Self, rhs: Swift.Bool) -> GRDB.SQLExpression
  public static func == (lhs: (any GRDB.SQLExpressible)?, rhs: Self) -> GRDB.SQLExpression
  public static func == (lhs: Swift.Bool, rhs: Self) -> GRDB.SQLExpression
  public static func == (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func != (lhs: Self, rhs: (any GRDB.SQLExpressible)?) -> GRDB.SQLExpression
  public static func != (lhs: Self, rhs: Swift.Bool) -> GRDB.SQLExpression
  public static func != (lhs: (any GRDB.SQLExpressible)?, rhs: Self) -> GRDB.SQLExpression
  public static func != (lhs: Swift.Bool, rhs: Self) -> GRDB.SQLExpression
  public static func != (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func === (lhs: Self, rhs: (any GRDB.SQLExpressible)?) -> GRDB.SQLExpression
  public static func === (lhs: (any GRDB.SQLExpressible)?, rhs: Self) -> GRDB.SQLExpression
  public static func === (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func !== (lhs: Self, rhs: (any GRDB.SQLExpressible)?) -> GRDB.SQLExpression
  public static func !== (lhs: (any GRDB.SQLExpressible)?, rhs: Self) -> GRDB.SQLExpression
  public static func !== (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func < (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func < (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func < (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func <= (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func <= (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func <= (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func > (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func > (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func > (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func >= (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func >= (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func >= (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension Swift.Range where Bound : GRDB.SQLExpressible {
  public func contains(_ element: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension Swift.ClosedRange where Bound : GRDB.SQLExpressible {
  public func contains(_ element: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension Swift.CountableRange where Bound : GRDB.SQLExpressible, Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public func contains(_ element: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension Swift.CountableClosedRange where Bound : GRDB.SQLExpressible, Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger {
  public func contains(_ element: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension Swift.Sequence where Self.Element : GRDB.SQLExpressible {
  public func contains(_ element: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension Swift.Sequence where Self.Element == any GRDB.SQLExpressible {
  public func contains(_ element: some SQLSpecificExpressible) -> GRDB.SQLExpression
}
extension GRDB.SQLSpecificExpressible {
  public static func * (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func * (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func * (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func / (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func / (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func / (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func + (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func + (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func + (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  prefix public static func - (value: Self) -> GRDB.SQLExpression
  public static func - (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func - (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func - (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func && (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func && (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func && (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func || (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func || (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func || (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  prefix public static func ! (value: Self) -> GRDB.SQLExpression
}
extension GRDB.SQLSpecificExpressible {
  public static func & (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func & (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func & (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func | (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func | (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func | (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func << (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func << (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func << (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  public static func >> (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
  public static func >> (lhs: some SQLExpressible, rhs: Self) -> GRDB.SQLExpression
  public static func >> (lhs: Self, rhs: some SQLSpecificExpressible) -> GRDB.SQLExpression
  prefix public static func ~ (value: Self) -> GRDB.SQLExpression
}
extension GRDB.SQLSpecificExpressible {
  public func like(_ pattern: some SQLExpressible, escape: (any GRDB.SQLExpressible)? = nil) -> GRDB.SQLExpression
}
public struct FTS3 {
  public enum Diacritics {
    case keep
    case removeLegacy
    @available(iOS 14, macOS 11.0, tvOS 14, watchOS 7, *)
    case remove
    public static func == (a: GRDB.FTS3.Diacritics, b: GRDB.FTS3.Diacritics) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init()
  public static func tokenize(_ string: Swift.String, withTokenizer tokenizer: GRDB.FTS3TokenizerDescriptor = .simple) throws -> [Swift.String]
}
extension GRDB.FTS3 : GRDB.VirtualTableModule {
  public var moduleName: Swift.String {
    get
  }
  public func makeTableDefinition(configuration: GRDB.VirtualTableConfiguration) -> GRDB.FTS3TableDefinition
  public func moduleArguments(for definition: GRDB.FTS3TableDefinition, in db: GRDB.Database) -> [Swift.String]
  public func database(_ db: GRDB.Database, didCreate tableName: Swift.String, using definition: GRDB.FTS3TableDefinition)
  public typealias TableDefinition = GRDB.FTS3TableDefinition
}
@_hasMissingDesignatedInitializers final public class FTS3TableDefinition {
  final public var tokenizer: GRDB.FTS3TokenizerDescriptor?
  final public func column(_ name: Swift.String)
  @objc deinit
}
extension GRDB.MutablePersistableRecord {
  @inline(__always) @inlinable public func willDelete(_ db: GRDB.Database) throws { }
  @inline(__always) @inlinable public func aroundDelete(_ db: GRDB.Database, delete: () throws -> Swift.Bool) throws {
        _ = try delete()
    }
  @inline(__always) @inlinable public func didDelete(deleted: Swift.Bool) { }
}
extension GRDB.MutablePersistableRecord {
  @discardableResult
  @inlinable public func delete(_ db: GRDB.Database) throws -> Swift.Bool {
        try willDelete(db)
        
        var deleted: Bool?
        try aroundDelete(db) {
            deleted = try deleteWithoutCallbacks(db)
            return deleted!
        }
        
        guard let deleted else {
            try persistenceCallbackMisuse("aroundDelete")
        }
        didDelete(deleted: deleted)
        return deleted
    }
}
extension GRDB.MutablePersistableRecord {
  @usableFromInline
  internal func deleteWithoutCallbacks(_ db: GRDB.Database) throws -> Swift.Bool
}
public protocol DatabaseCancellable {
  func cancel()
}
public class AnyDatabaseCancellable : GRDB.DatabaseCancellable {
  public init(cancel: @escaping () -> Swift.Void)
  convenience public init(_ base: some DatabaseCancellable)
  @objc deinit
  public func cancel()
}
extension GRDB.ValueObservation {
  public func removeDuplicates(by predicate: @escaping (Reducer.Value, Reducer.Value) -> Swift.Bool) -> GRDB.ValueObservation<GRDB.ValueReducers.RemoveDuplicates<Reducer>>
}
extension GRDB.ValueObservation where Reducer.Value : Swift.Equatable {
  public func removeDuplicates() -> GRDB.ValueObservation<GRDB.ValueReducers.RemoveDuplicates<Reducer>>
}
extension GRDB.ValueReducers {
  public struct RemoveDuplicates<Base> : GRDB._ValueReducer where Base : GRDB._ValueReducer {
    public mutating func _value(_ fetched: Base.Fetched) throws -> Base.Value?
    public typealias Fetched = Base.Fetched
    public typealias Value = Base.Value
  }
}
extension GRDB.ValueReducers.RemoveDuplicates : GRDB.ValueReducer where Base : GRDB.ValueReducer {
  public func _fetch(_ db: GRDB.Database) throws -> Base.Fetched
}
public protocol FTS5CustomTokenizer : GRDB.FTS5Tokenizer {
  static var name: Swift.String { get }
  init(db: GRDB.Database, arguments: [Swift.String]) throws
}
extension GRDB.FTS5CustomTokenizer {
  public static func tokenizerDescriptor(arguments: [Swift.String] = []) -> GRDB.FTS5TokenizerDescriptor
}
extension GRDB.Database {
  final public func add(tokenizer: (some FTS5CustomTokenizer).Type)
}
public struct IndexOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let ifNotExists: GRDB.IndexOptions
  public static let unique: GRDB.IndexOptions
  public typealias ArrayLiteralElement = GRDB.IndexOptions
  public typealias Element = GRDB.IndexOptions
  public typealias RawValue = Swift.Int
}
final public class DatabaseCollation {
  final public let name: Swift.String
  public init(_ name: Swift.String, function: @escaping (Swift.String, Swift.String) -> Foundation.ComparisonResult)
  @objc deinit
}
extension GRDB.DatabaseCollation : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: GRDB.DatabaseCollation, rhs: GRDB.DatabaseCollation) -> Swift.Bool
  final public var hashValue: Swift.Int {
    get
  }
}
extension CoreFoundation.CGFloat : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> CoreFoundation.CGFloat?
}
extension GRDB.DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self.ReferenceType : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self : Swift.Decodable, Self.ReferenceType : GRDB.DatabaseValueConvertible {
  public static func fromDatabaseValue(_ databaseValue: GRDB.DatabaseValue) -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self : Swift.Encodable, Self.ReferenceType : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
}
final public class DatabaseSnapshotPool {
  final public let configuration: GRDB.Configuration
  final public let path: Swift.String
  public init(_ db: GRDB.Database, configuration: GRDB.Configuration? = nil) throws
  public init(path: Swift.String, configuration: GRDB.Configuration = Configuration()) throws
  @objc deinit
}
extension GRDB.DatabaseSnapshotPool : @unchecked Swift.Sendable {
}
extension GRDB.DatabaseSnapshotPool : GRDB.DatabaseSnapshotReader {
  final public func close() throws
  final public func interrupt()
  @_disfavoredOverload final public func read<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
extension Foundation.NSDate : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
extension Foundation.Date : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Foundation.Date?
  @usableFromInline
  internal init?(databaseDateComponents: GRDB.DatabaseDateComponents)
  public init?(julianDay: Swift.Double)
}
extension Foundation.Date : GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        switch sqlite3_column_type(sqliteStatement, index) {
        case SQLITE_INTEGER, SQLITE_FLOAT:
            self.init(timeIntervalSince1970: sqlite3_column_double(sqliteStatement, index))
        case SQLITE_TEXT:
            guard let components = DatabaseDateComponents(sqliteStatement: sqliteStatement, index: index),
                  let date = Date(databaseDateComponents: components)
            else {
                return nil
            }
            self.init(timeIntervalSinceReferenceDate: date.timeIntervalSinceReferenceDate)
        default:
            return nil
        }
    }
}
extension GRDB.SQLSelectable where Self : Swift.RawRepresentable, Self.RawValue : GRDB.SQLSelectable {
  public var sqlSelection: GRDB.SQLSelection {
    get
  }
}
extension GRDB.SQLOrderingTerm where Self : Swift.RawRepresentable, Self.RawValue : GRDB.SQLOrderingTerm {
  public var sqlOrdering: GRDB.SQLOrdering {
    get
  }
}
extension GRDB.SQLExpressible where Self : Swift.RawRepresentable, Self.RawValue : GRDB.SQLExpressible {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
extension GRDB.StatementBinding where Self : Swift.RawRepresentable, Self.RawValue : GRDB.StatementBinding {
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension GRDB.StatementColumnConvertible where Self : Swift.RawRepresentable, Self.RawValue : GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        guard let rawValue = RawValue(sqliteStatement: sqliteStatement, index: index) else {
            return nil
        }
        self.init(rawValue: rawValue)
    }
}
extension GRDB.DatabaseValueConvertible where Self : Swift.RawRepresentable, Self.RawValue : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
public struct Configuration {
  public var foreignKeysEnabled: Swift.Bool
  public var readonly: Swift.Bool
  public var label: Swift.String?
  public var acceptsDoubleQuotedStringLiterals: Swift.Bool
  public var observesSuspensionNotifications: Swift.Bool
  public var publicStatementArguments: Swift.Bool
  public var transactionClock: any GRDB.TransactionClock
  public mutating func prepareDatabase(_ setup: @escaping (GRDB.Database) throws -> Swift.Void)
  public var defaultTransactionKind: GRDB.Database.TransactionKind
  public var allowsUnsafeTransactions: Swift.Bool
  public var busyMode: GRDB.Database.BusyMode
  public var maximumReaderCount: Swift.Int
  public var qos: Dispatch.DispatchQoS
  public var readQoS: Dispatch.DispatchQoS {
    get
  }
  public var writeQoS: Dispatch.DispatchQoS {
    get
  }
  public var targetQueue: Dispatch.DispatchQueue?
  public var writeTargetQueue: Dispatch.DispatchQueue?
  public var automaticMemoryManagement: Swift.Bool
  public var persistentReadOnlyConnections: Swift.Bool
  public init()
}
extension GRDB.PersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func upsert(_ db: GRDB.Database) throws {
        try willSave(db)
        
        var saved: PersistenceSuccess?
        try aroundSave(db) {
            let inserted = try upsertWithCallbacks(db)
            saved = PersistenceSuccess(inserted)
            return saved!
        }
        
        guard let saved else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(saved)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func upsertAndFetch(_ db: GRDB.Database, onConflict conflictTarget: [Swift.String] = [], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])? = nil) throws -> Self where Self : GRDB.FetchableRecord {
        try upsertAndFetch(db, as: Self.self, onConflict: conflictTarget, doUpdate: assignments)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func upsertAndFetch<T>(_ db: GRDB.Database, as returnedType: T.Type, onConflict conflictTarget: [Swift.String] = [], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])? = nil) throws -> T where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try willSave(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundSave(db) {
            success = try upsertAndFetchWithCallbacks(
                db, onConflict: conflictTarget,
                doUpdate: assignments,
                selection: T.databaseSelection,
                decode: { try T(row: $0) })
            return PersistenceSuccess(success!.inserted)
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(PersistenceSuccess(success.inserted))
        return success.returned
    }
}
extension GRDB.PersistableRecord {
  @inlinable internal func upsertWithCallbacks(_ db: GRDB.Database) throws -> GRDB.InsertionSuccess {
        let (inserted, _) = try upsertAndFetchWithCallbacks(
            db, onConflict: [],
            doUpdate: nil,
            selection: [],
            decode: { _ in /* Nothing to decode */ })
        return inserted
    }
  @inlinable internal func upsertAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictTarget: [Swift.String], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])?, selection: [any GRDB.SQLSelectable], decode: (GRDB.Row) throws -> T) throws -> (GRDB.InsertionSuccess, T) {
        try willInsert(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundInsert(db) {
            success = try upsertAndFetchWithoutCallbacks(
                db, onConflict: conflictTarget,
                doUpdate: assignments,
                selection: selection,
                decode: decode)
            return success!.inserted
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundInsert")
        }
        didInsert(success.inserted)
        return success
    }
}
public func abs(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func average(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func count(_ counted: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func count(distinct value: some SQLSpecificExpressible) -> GRDB.SQLExpression
extension GRDB.SQLSpecificExpressible {
  public static func ?? (lhs: Self, rhs: some SQLExpressible) -> GRDB.SQLExpression
}
public func length(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func max(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func min(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func sum(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
public func total(_ value: some SQLSpecificExpressible) -> GRDB.SQLExpression
extension GRDB.SQLSpecificExpressible {
  public var capitalized: GRDB.SQLExpression {
    get
  }
  public var lowercased: GRDB.SQLExpression {
    get
  }
  public var uppercased: GRDB.SQLExpression {
    get
  }
}
extension GRDB.SQLSpecificExpressible {
  public var localizedCapitalized: GRDB.SQLExpression {
    get
  }
  public var localizedLowercased: GRDB.SQLExpression {
    get
  }
  public var localizedUppercased: GRDB.SQLExpression {
    get
  }
}
public enum SQLDateModifier : GRDB.SQLSpecificExpressible {
  case second(Swift.Double)
  case minute(Swift.Int)
  case hour(Swift.Int)
  case day(Swift.Int)
  case month(Swift.Int)
  case year(Swift.Int)
  case startOfDay
  case startOfMonth
  case startOfYear
  case weekday(Swift.Int)
  case unixEpoch
  case localTime
  case utc
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
public func julianDay(_ value: some SQLSpecificExpressible, _ modifiers: GRDB.SQLDateModifier...) -> GRDB.SQLExpression
public func dateTime(_ value: some SQLSpecificExpressible, _ modifiers: GRDB.SQLDateModifier...) -> GRDB.SQLExpression
public struct FTS3Pattern {
  public let rawPattern: Swift.String
  public init(rawPattern: Swift.String) throws
  public init?(matchingAnyTokenIn string: Swift.String)
  public init?(matchingAllTokensIn string: Swift.String)
  public init?(matchingAllPrefixesIn string: Swift.String)
  public init?(matchingPhrase string: Swift.String)
}
extension GRDB.FTS3Pattern : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> GRDB.FTS3Pattern?
}
final public class DatabaseFunction : Swift.Hashable {
  final public var name: Swift.String {
    get
  }
  public init(_ name: Swift.String, argumentCount: Swift.Int? = nil, pure: Swift.Bool = false, function: @escaping ([GRDB.DatabaseValue]) throws -> (any GRDB.DatabaseValueConvertible)?)
  public init<Aggregate>(_ name: Swift.String, argumentCount: Swift.Int? = nil, pure: Swift.Bool = false, aggregate: Aggregate.Type) where Aggregate : GRDB.DatabaseAggregate
  final public func callAsFunction(_ arguments: any GRDB.SQLExpressible...) -> GRDB.SQLExpression
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension GRDB.DatabaseFunction {
  final public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: GRDB.DatabaseFunction, rhs: GRDB.DatabaseFunction) -> Swift.Bool
}
public protocol DatabaseAggregate {
  init()
  mutating func step(_ dbValues: [GRDB.DatabaseValue]) throws
  func finalize() throws -> (any GRDB.DatabaseValueConvertible)?
}
public struct DatabaseRegionObservation {
}
extension GRDB.DatabaseRegionObservation {
  public init(tracking regions: any GRDB.DatabaseRegionConvertible...)
  public init(tracking regions: [any GRDB.DatabaseRegionConvertible])
}
extension GRDB.DatabaseRegionObservation {
  public func start(in writer: some DatabaseWriter, onError: @escaping (any Swift.Error) -> Swift.Void, onChange: @escaping (GRDB.Database) -> Swift.Void) -> GRDB.AnyDatabaseCancellable
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.DatabaseRegionObservation {
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func publisher(in writer: some DatabaseWriter) -> GRDB.DatabasePublishers.DatabaseRegion
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.DatabasePublishers {
  public struct DatabaseRegion : Combine.Publisher {
    public typealias Output = GRDB.Database
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == GRDB.Database
  }
}
public protocol ValueObservationScheduler {
  func immediateInitialValue() -> Swift.Bool
  func schedule(_ action: @escaping () -> Swift.Void)
}
public struct AsyncValueObservationScheduler : GRDB.ValueObservationScheduler {
  public init(queue: Dispatch.DispatchQueue)
  public func immediateInitialValue() -> Swift.Bool
  public func schedule(_ action: @escaping () -> Swift.Void)
}
extension GRDB.ValueObservationScheduler where Self == GRDB.AsyncValueObservationScheduler {
  public static func async(onQueue queue: Dispatch.DispatchQueue) -> GRDB.AsyncValueObservationScheduler
}
public struct ImmediateValueObservationScheduler : GRDB.ValueObservationScheduler {
  public init()
  public func immediateInitialValue() -> Swift.Bool
  public func schedule(_ action: @escaping () -> Swift.Void)
}
extension GRDB.ValueObservationScheduler where Self == GRDB.ImmediateValueObservationScheduler {
  public static var immediate: GRDB.ImmediateValueObservationScheduler {
    get
  }
}
extension GRDB.EncodableRecord where Self : Swift.Encodable {
  public func encode(to container: inout GRDB.PersistenceContainer) throws
}
extension GRDB.PersistableRecord {
  @inlinable public func save(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws {
        try willSave(db)
        
        var saved: PersistenceSuccess?
        try aroundSave(db) {
            saved = try updateOrInsertWithCallbacks(db, onConflict: conflictResolution)
            return saved!
        }
        
        guard let saved else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(saved)
    }
}
extension GRDB.PersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func saveAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, as returnedType: T.Type) throws -> T? where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try willSave(db)
        
        var success: (saved: PersistenceSuccess, returned: T?)?
        try aroundSave(db) {
            success = try updateOrInsertAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                selection: T.databaseSelection,
                fetch: {
                    try T.fetchOne($0)
                })
            return success!.saved
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(success.saved)
        return success.returned
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func saveAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T {
        GRDBPrecondition(!selection.isEmpty, "Invalid empty selection")
        
        try willSave(db)
        
        var success: (saved: PersistenceSuccess, returned: T)?
        try aroundSave(db) {
            success = try updateOrInsertAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                selection: selection,
                fetch: fetch)
            return success!.saved
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(success.saved)
        return success.returned
    }
}
extension GRDB.PersistableRecord {
  @inlinable internal func updateOrInsertWithCallbacks(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?) throws -> GRDB.PersistenceSuccess {
        let (saved, _) = try updateOrInsertAndFetchWithCallbacks(
            db, onConflict: conflictResolution,
            selection: [],
            fetch: {
                // Nothing to fetch
                try $0.execute()
            })
        return saved
    }
  @inlinable internal func updateOrInsertAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.PersistenceSuccess, T) {
        // Attempt at updating if the record has a primary key
        if let key = try primaryKey(db) {
            do {
                let databaseTableName = type(of: self).databaseTableName
                let columns = try Set(db.columns(in: databaseTableName).map(\.name))
                return try updateAndFetchWithCallbacks(
                    db, onConflict: conflictResolution,
                    columns: columns,
                    selection: selection,
                    fetch: fetch)
            } catch RecordError.recordNotFound(databaseTableName: type(of: self).databaseTableName, key: key) {
                // No row was updated: fallback on insert.
            }
        }
        
        // Insert
        let (inserted, returned) = try insertAndFetchWithCallbacks(
            db, onConflict: conflictResolution,
            selection: selection,
            fetch: fetch)
        return (PersistenceSuccess(inserted), returned)
    }
}
extension GRDB.Database {
  @_disfavoredOverload final public func create(table name: Swift.String, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, withoutRowID: Swift.Bool = false, body: (GRDB.TableDefinition) throws -> Swift.Void) throws
  final public func create(table name: Swift.String, options: GRDB.TableOptions = [], body: (GRDB.TableDefinition) throws -> Swift.Void) throws
  final public func rename(table name: Swift.String, to newName: Swift.String) throws
  final public func alter(table name: Swift.String, body: (GRDB.TableAlteration) -> Swift.Void) throws
  final public func drop(table name: Swift.String) throws
  final public func create(view name: Swift.String, options: GRDB.ViewOptions = [], columns: [Swift.String]? = nil, as request: any GRDB.SQLSubqueryable) throws
  final public func create(view name: Swift.String, options: GRDB.ViewOptions = [], columns: [Swift.String]? = nil, asLiteral sqlLiteral: GRDB.SQL) throws
  final public func drop(view name: Swift.String) throws
  @_disfavoredOverload final public func create(index name: Swift.String, on table: Swift.String, columns: [Swift.String], unique: Swift.Bool = false, ifNotExists: Swift.Bool = false, condition: (any GRDB.SQLExpressible)? = nil) throws
  final public func create(index name: Swift.String, on table: Swift.String, columns: [Swift.String], options: GRDB.IndexOptions = [], condition: (any GRDB.SQLExpressible)? = nil) throws
  final public func create(indexOn table: Swift.String, columns: [Swift.String], options: GRDB.IndexOptions = [], condition: (any GRDB.SQLExpressible)? = nil) throws
  final public func drop(index name: Swift.String) throws
  final public func drop(indexOn table: Swift.String, columns: [Swift.String]) throws
  final public func reindex(collation: GRDB.Database.CollationName) throws
  final public func reindex(collation: GRDB.DatabaseCollation) throws
}
public struct ViewOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let ifNotExists: GRDB.ViewOptions
  public static let temporary: GRDB.ViewOptions
  public typealias ArrayLiteralElement = GRDB.ViewOptions
  public typealias Element = GRDB.ViewOptions
  public typealias RawValue = Swift.Int
}
public func splittingRowAdapters(columnCounts: [Swift.Int]) -> [any GRDB.RowAdapter]
public struct _LayoutedColumnMapping {
  public let _layoutColumns: [(Swift.Int, Swift.String)]
}
extension GRDB._LayoutedColumnMapping : GRDB._LayoutedRowAdapter {
  public var _mapping: GRDB._LayoutedColumnMapping {
    get
  }
  public var _scopes: [Swift.String : any GRDB._LayoutedRowAdapter] {
    get
  }
}
extension GRDB._LayoutedColumnMapping : GRDB._RowLayout {
  public func _layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol _LayoutedRowAdapter {
  var _mapping: GRDB._LayoutedColumnMapping { get }
  var _scopes: [Swift.String : any GRDB._LayoutedRowAdapter] { get }
}
public protocol _RowLayout {
  var _layoutColumns: [(Swift.Int, Swift.String)] { get }
  func _layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
extension GRDB.Statement : GRDB._RowLayout {
  final public var _layoutColumns: [(Swift.Int, Swift.String)] {
    get
  }
  final public func _layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol RowAdapter {
  func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
extension GRDB.RowAdapter {
  public func addingScopes(_ scopes: [Swift.String : any GRDB.RowAdapter]) -> any GRDB.RowAdapter
}
public struct EmptyRowAdapter : GRDB.RowAdapter {
  public init()
  public func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
public struct ColumnMapping : GRDB.RowAdapter {
  public init(_ mapping: [Swift.String : Swift.String])
  public func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
public struct SuffixRowAdapter : GRDB.RowAdapter {
  public init(fromIndex index: Swift.Int)
  public func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
public struct RangeRowAdapter : GRDB.RowAdapter {
  public init(_ range: Swift.CountableRange<Swift.Int>)
  public init(_ range: Swift.CountableClosedRange<Swift.Int>)
  public func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
public struct ScopeAdapter : GRDB.RowAdapter {
  public init(_ scopes: [Swift.String : any GRDB.RowAdapter])
  public init(base: some RowAdapter, scopes: [Swift.String : any GRDB.RowAdapter])
  public func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
public struct RenameColumnAdapter : GRDB.RowAdapter {
  public init(_ transform: @escaping (Swift.String) -> Swift.String)
  public func _layoutedAdapter(from layout: some _RowLayout) throws -> any GRDB._LayoutedRowAdapter
}
public struct BelongsToAssociation<Origin, Destination> {
  public var _sqlAssociation: GRDB._SQLAssociation
}
extension GRDB.BelongsToAssociation : GRDB.AssociationToOne {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
}
public protocol DatabaseWriter : GRDB.DatabaseReader {
  @_disfavoredOverload func writeWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  @_disfavoredOverload func barrierWriteWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) throws -> T
  func asyncBarrierWriteWithoutTransaction(_ updates: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  func asyncWriteWithoutTransaction(_ updates: @escaping (GRDB.Database) -> Swift.Void)
  func unsafeReentrantWrite<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  func concurrentRead<T>(_ value: @escaping (GRDB.Database) throws -> T) -> GRDB.DatabaseFuture<T>
  func spawnConcurrentRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
}
extension GRDB.DatabaseWriter {
  @_disfavoredOverload public func write<T>(_ updates: (GRDB.Database) throws -> T) throws -> T
  public func asyncWrite<T>(_ updates: @escaping (GRDB.Database) throws -> T, completion: @escaping (GRDB.Database, Swift.Result<T, any Swift.Error>) -> Swift.Void)
  public func add(transactionObserver: some TransactionObserver, extent: GRDB.Database.TransactionObservationExtent = .observerLifetime)
  public func remove(transactionObserver: some TransactionObserver)
  @_disfavoredOverload public func erase() throws
  @_disfavoredOverload public func vacuum() throws
  @available(iOS 14, macOS 11.0, tvOS 14, watchOS 7, *)
  @_disfavoredOverload public func vacuum(into filePath: Swift.String) throws
}
extension GRDB.DatabaseWriter {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func write<T>(_ updates: @escaping @Sendable (GRDB.Database) throws -> T) async throws -> T
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func writeWithoutTransaction<T>(_ updates: @escaping @Sendable (GRDB.Database) throws -> T) async throws -> T
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func barrierWriteWithoutTransaction<T>(_ updates: @escaping @Sendable (GRDB.Database) throws -> T) async throws -> T
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func erase() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func vacuum() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func vacuum(into filePath: Swift.String) async throws
  #endif
}
extension GRDB.DatabaseWriter {
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func writePublisher<Output>(receiveOn scheduler: some Combine.Scheduler = DispatchQueue.main, updates: @escaping (GRDB.Database) throws -> Output) -> GRDB.DatabasePublishers.Write<Output>
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func writePublisher<S, T, Output>(receiveOn scheduler: S = DispatchQueue.main, updates: @escaping (GRDB.Database) throws -> T, thenRead value: @escaping (GRDB.Database, T) throws -> Output) -> GRDB.DatabasePublishers.Write<Output> where S : Combine.Scheduler
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.DatabasePublishers {
  public struct Write<Output> : Combine.Publisher {
    public typealias Output = Output
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == any Swift.Error
  }
}
@_hasMissingDesignatedInitializers public class DatabaseFuture<Value> {
  public func wait() throws -> Value
  @objc deinit
}
final public class AnyDatabaseWriter {
  public init(_ base: some DatabaseWriter)
  @objc deinit
}
extension GRDB.AnyDatabaseWriter : GRDB.DatabaseReader {
  final public var configuration: GRDB.Configuration {
    get
  }
  final public func close() throws
  final public func interrupt()
  @_disfavoredOverload final public func read<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  @_disfavoredOverload final public func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
extension GRDB.AnyDatabaseWriter : GRDB.DatabaseWriter {
  @_disfavoredOverload final public func writeWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  @_disfavoredOverload final public func barrierWriteWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) throws -> T
  final public func asyncBarrierWriteWithoutTransaction(_ updates: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func asyncWriteWithoutTransaction(_ updates: @escaping (GRDB.Database) -> Swift.Void)
  final public func unsafeReentrantWrite<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  final public func concurrentRead<T>(_ value: @escaping (GRDB.Database) throws -> T) -> GRDB.DatabaseFuture<T>
  final public func spawnConcurrentRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
}
extension GRDB.Inflections {
  public static var `default`: GRDB.Inflections
}
public struct _SQLAssociation {
}
public protocol EncodableRecord {
  func encode(to container: inout GRDB.PersistenceContainer) throws
  static var databaseEncodingUserInfo: [Swift.CodingUserInfoKey : Any] { get }
  static func databaseJSONEncoder(for column: Swift.String) -> Foundation.JSONEncoder
  static var databaseDateEncodingStrategy: GRDB.DatabaseDateEncodingStrategy { get }
  static var databaseUUIDEncodingStrategy: GRDB.DatabaseUUIDEncodingStrategy { get }
  static var databaseColumnEncodingStrategy: GRDB.DatabaseColumnEncodingStrategy { get }
}
extension GRDB.EncodableRecord {
  public static var databaseEncodingUserInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public static func databaseJSONEncoder(for column: Swift.String) -> Foundation.JSONEncoder
  public static var databaseDateEncodingStrategy: GRDB.DatabaseDateEncodingStrategy {
    get
  }
  public static var databaseUUIDEncodingStrategy: GRDB.DatabaseUUIDEncodingStrategy {
    get
  }
  public static var databaseColumnEncodingStrategy: GRDB.DatabaseColumnEncodingStrategy {
    get
  }
}
extension GRDB.EncodableRecord {
  #if compiler(>=5.3) && $EffectfulProp
  public var databaseDictionary: [Swift.String : GRDB.DatabaseValue] {
    get throws
  }
  #endif
}
extension GRDB.EncodableRecord {
  public func databaseEquals(_ record: Self) -> Swift.Bool
  public func databaseChanges(from record: some EncodableRecord) throws -> [Swift.String : GRDB.DatabaseValue]
  public mutating func databaseChanges(modify: (inout Self) throws -> Swift.Void) throws -> [Swift.String : GRDB.DatabaseValue]
}
public struct PersistenceContainer {
  public subscript(column: Swift.String) -> (any GRDB.DatabaseValueConvertible)? {
    get
    set
  }
  public subscript(column: some ColumnExpression) -> (any GRDB.DatabaseValueConvertible)? {
    get
    set
  }
  @usableFromInline
  internal init(_ db: GRDB.Database, _ record: some EncodableRecord & TableRecord) throws
  @usableFromInline
  internal func changesIterator(from container: GRDB.PersistenceContainer) -> Swift.AnyIterator<(Swift.String, GRDB.DatabaseValue)>
}
public enum DatabaseDateEncodingStrategy {
  case deferredToDate
  case timeIntervalSinceReferenceDate
  case timeIntervalSince1970
  case secondsSince1970
  case millisecondsSince1970
  case iso8601
  case formatted(Foundation.DateFormatter)
  case custom((Foundation.Date) -> (any GRDB.DatabaseValueConvertible)?)
}
public enum DatabaseUUIDEncodingStrategy {
  case deferredToUUID
  case uppercaseString
  case lowercaseString
  public static func == (a: GRDB.DatabaseUUIDEncodingStrategy, b: GRDB.DatabaseUUIDEncodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DatabaseColumnEncodingStrategy {
  case useDefaultKeys
  case convertToSnakeCase
  case custom((any Swift.CodingKey) -> Swift.String)
}
public typealias FTS5TokenCallback = @convention(c) (_ context: Swift.UnsafeMutableRawPointer?, _ flags: Swift.CInt, _ pToken: Swift.UnsafePointer<Swift.Int8>?, _ nToken: Swift.CInt, _ iStart: Swift.CInt, _ iEnd: Swift.CInt) -> Swift.CInt
public struct FTS5Tokenization : Swift.OptionSet {
  public let rawValue: Swift.CInt
  public init(rawValue: Swift.CInt)
  public static let query: GRDB.FTS5Tokenization
  public static let prefix: GRDB.FTS5Tokenization
  public static let document: GRDB.FTS5Tokenization
  public static let aux: GRDB.FTS5Tokenization
  public typealias ArrayLiteralElement = GRDB.FTS5Tokenization
  public typealias Element = GRDB.FTS5Tokenization
  public typealias RawValue = Swift.CInt
}
public protocol FTS5Tokenizer : AnyObject {
  func tokenize(context: Swift.UnsafeMutableRawPointer?, tokenization: GRDB.FTS5Tokenization, pText: Swift.UnsafePointer<Swift.Int8>?, nText: Swift.CInt, tokenCallback: GRDB.FTS5TokenCallback) -> Swift.CInt
}
extension GRDB.FTS5Tokenizer {
  public func tokenize(document string: Swift.String) throws -> [(token: Swift.String, flags: GRDB.FTS5TokenFlags)]
  public func tokenize(query string: Swift.String) throws -> [(token: Swift.String, flags: GRDB.FTS5TokenFlags)]
}
extension GRDB.Database {
  final public func makeTokenizer(_ descriptor: GRDB.FTS5TokenizerDescriptor) throws -> any GRDB.FTS5Tokenizer
}
public struct FTS5TokenizerDescriptor {
  public let components: [Swift.String]
  public init(components: [Swift.String])
  public static func ascii(separators: Swift.Set<Swift.Character> = [], tokenCharacters: Swift.Set<Swift.Character> = []) -> GRDB.FTS5TokenizerDescriptor
  public static func porter(wrapping base: GRDB.FTS5TokenizerDescriptor? = nil) -> GRDB.FTS5TokenizerDescriptor
  public static func unicode61(diacritics: GRDB.FTS5.Diacritics = .removeLegacy, categories: Swift.String = "", separators: Swift.Set<Swift.Character> = [], tokenCharacters: Swift.Set<Swift.Character> = []) -> GRDB.FTS5TokenizerDescriptor
}
public struct DatabaseBackupProgress {
  public let remainingPageCount: Swift.Int
  public let totalPageCount: Swift.Int
  public var completedPageCount: Swift.Int {
    get
  }
  public let isCompleted: Swift.Bool
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
public enum DatabasePublishers {
}
@_hasMissingDesignatedInitializers final public class ForeignKeyDefinition {
  @discardableResult
  final public func notNull(onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func unique() -> Self
  @objc deinit
}
extension GRDB.MutablePersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func upsert(_ db: GRDB.Database) throws {
        try willSave(db)
        
        var saved: PersistenceSuccess?
        try aroundSave(db) {
            let inserted = try upsertWithCallbacks(db)
            saved = PersistenceSuccess(inserted)
            return saved!
        }
        
        guard let saved else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(saved)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func upsertAndFetch(_ db: GRDB.Database, onConflict conflictTarget: [Swift.String] = [], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])? = nil) throws -> Self where Self : GRDB.FetchableRecord {
        try upsertAndFetch(db, as: Self.self, onConflict: conflictTarget, doUpdate: assignments)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func upsertAndFetch<T>(_ db: GRDB.Database, as returnedType: T.Type, onConflict conflictTarget: [Swift.String] = [], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])? = nil) throws -> T where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try willSave(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundSave(db) {
            success = try upsertAndFetchWithCallbacks(
                db, onConflict: conflictTarget,
                doUpdate: assignments,
                selection: T.databaseSelection,
                decode: { try T(row: $0) })
            return PersistenceSuccess(success!.inserted)
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(PersistenceSuccess(success.inserted))
        return success.returned
    }
}
extension GRDB.MutablePersistableRecord {
  @inlinable internal mutating func upsertWithCallbacks(_ db: GRDB.Database) throws -> GRDB.InsertionSuccess {
        let (inserted, _) = try upsertAndFetchWithCallbacks(
            db, onConflict: [],
            doUpdate: nil,
            selection: [],
            decode: { _ in /* Nothing to decode */ })
        return inserted
    }
  @inlinable internal mutating func upsertAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictTarget: [Swift.String], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])?, selection: [any GRDB.SQLSelectable], decode: (GRDB.Row) throws -> T) throws -> (GRDB.InsertionSuccess, T) {
        try willInsert(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundInsert(db) {
            success = try upsertAndFetchWithoutCallbacks(
                db, onConflict: conflictTarget,
                doUpdate: assignments,
                selection: selection,
                decode: decode)
            return success!.inserted
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundInsert")
        }
        didInsert(success.inserted)
        return success
    }
  @usableFromInline
  internal func upsertAndFetchWithoutCallbacks<T>(_ db: GRDB.Database, onConflict conflictTarget: [Swift.String], doUpdate assignments: ((_ excluded: GRDB.TableAlias) -> [GRDB.ColumnAssignment])?, selection: [any GRDB.SQLSelectable], decode: (GRDB.Row) throws -> T) throws -> (GRDB.InsertionSuccess, T)
}
extension Foundation.NSString : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
public protocol DatabaseValueConvertible : GRDB.SQLExpressible, GRDB.StatementBinding {
  var databaseValue: GRDB.DatabaseValue { get }
  static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
  static func fromMissingColumn() -> Self?
}
extension GRDB.DatabaseValueConvertible {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
  public static func fromMissingColumn() -> Self?
}
extension GRDB.DatabaseValueConvertible {
  @usableFromInline
  internal static func decode(fromRow row: GRDB.Row, atUncheckedIndex index: Swift.Int) throws -> Self
  @usableFromInline
  internal static func decodeIfPresent(fromRow row: GRDB.Row, atUncheckedIndex index: Swift.Int) throws -> Self?
}
@_hasMissingDesignatedInitializers final public class DatabaseValueCursor<Value> : GRDB.DatabaseCursor where Value : GRDB.DatabaseValueConvertible {
  public typealias Element = Value
  final public let _statement: GRDB.Statement
  final public var _isDone: Swift.Bool
  @objc deinit
  final public func _element(sqliteStatement: GRDB.SQLiteStatement) throws -> Value
}
extension GRDB.DatabaseValueConvertible {
  public static func fetchCursor(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.DatabaseValueCursor<Self>
  public static func fetchAll(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Hashable {
  public static func fetchSet(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<Self>
}
extension GRDB.DatabaseValueConvertible {
  public static func fetchCursor(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.DatabaseValueCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<Self>
}
extension GRDB.DatabaseValueConvertible {
  public static func fetchCursor(_ db: GRDB.Database, _ request: some FetchRequest) throws -> GRDB.DatabaseValueCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, _ request: some FetchRequest) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Swift.Set<Self>
}
extension GRDB.FetchRequest where Self.RowDecoder : GRDB.DatabaseValueConvertible {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.DatabaseValueCursor<Self.RowDecoder>
  public func fetchAll(_ db: GRDB.Database) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: GRDB.Database) throws -> Self.RowDecoder?
}
extension GRDB.FetchRequest where Self.RowDecoder : GRDB.DatabaseValueConvertible, Self.RowDecoder : Swift.Hashable {
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<Self.RowDecoder>
}
extension Foundation.NSUUID : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
extension Foundation.UUID : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Foundation.UUID?
}
extension Foundation.UUID : GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        switch sqlite3_column_type(sqliteStatement, index) {
        case SQLITE_TEXT:
            let string = String(cString: sqlite3_column_text(sqliteStatement, index)!)
            guard let uuid = UUID(uuidString: string) else {
                return nil
            }
            self.init(uuid: uuid.uuid)
        case SQLITE_BLOB:
            guard sqlite3_column_bytes(sqliteStatement, index) == 16,
                  let blob = sqlite3_column_blob(sqliteStatement, index) else
            {
                return nil
            }
            self.init(uuid: blob.assumingMemoryBound(to: uuid_t.self).pointee)
        default:
            return nil
        }
    }
}
public struct FTS4 {
  public init()
}
extension GRDB.FTS4 : GRDB.VirtualTableModule {
  public var moduleName: Swift.String {
    get
  }
  public func makeTableDefinition(configuration: GRDB.VirtualTableConfiguration) -> GRDB.FTS4TableDefinition
  public func moduleArguments(for definition: GRDB.FTS4TableDefinition, in db: GRDB.Database) -> [Swift.String]
  public func database(_ db: GRDB.Database, didCreate tableName: Swift.String, using definition: GRDB.FTS4TableDefinition) throws
  public typealias TableDefinition = GRDB.FTS4TableDefinition
}
@_hasMissingDesignatedInitializers final public class FTS4TableDefinition {
  final public var tokenizer: GRDB.FTS3TokenizerDescriptor?
  final public var content: Swift.String? {
    get
    set
  }
  final public var compress: Swift.String?
  final public var uncompress: Swift.String?
  final public var matchinfo: Swift.String?
  final public var prefixes: Swift.Set<Swift.Int>?
  @discardableResult
  final public func column(_ name: Swift.String) -> GRDB.FTS4ColumnDefinition
  final public func synchronize(withTable tableName: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FTS4ColumnDefinition {
  @discardableResult
  final public func notIndexed() -> Self
  @discardableResult
  final public func asLanguageId() -> Self
  @objc deinit
}
extension GRDB.Database {
  final public func dropFTS4SynchronizationTriggers(forTable tableName: Swift.String) throws
}
extension GRDB.MutablePersistableRecord {
  @inline(__always) @inlinable public func willSave(_ db: GRDB.Database) throws { }
  @inline(__always) @inlinable public func aroundSave(_ db: GRDB.Database, save: () throws -> GRDB.PersistenceSuccess) throws {
        _ = try save()
    }
  @inline(__always) @inlinable public func didSave(_ saved: GRDB.PersistenceSuccess) { }
}
extension GRDB.MutablePersistableRecord {
  @inlinable public mutating func save(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws {
        try willSave(db)
        
        var saved: PersistenceSuccess?
        try aroundSave(db) {
            saved = try updateOrInsertWithCallbacks(db, onConflict: conflictResolution)
            return saved!
        }
        
        guard let saved else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(saved)
    }
  @inlinable public func saved(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws -> Self {
        var result = self
        try result.save(db, onConflict: conflictResolution)
        return result
    }
}
extension GRDB.MutablePersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func saveAndFetch(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws -> Self? where Self : GRDB.FetchableRecord {
        var result = self
        return try result.saveAndFetch(db, onConflict: conflictResolution, as: Self.self)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func saveAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, as returnedType: T.Type) throws -> T? where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try willSave(db)
        
        var success: (saved: PersistenceSuccess, returned: T?)?
        try aroundSave(db) {
            success = try updateOrInsertAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                selection: T.databaseSelection,
                fetch: {
                    try T.fetchOne($0)
                })
            return success!.saved
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(success.saved)
        return success.returned
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func saveAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T {
        GRDBPrecondition(!selection.isEmpty, "Invalid empty selection")
        
        try willSave(db)
        
        var success: (saved: PersistenceSuccess, returned: T)?
        try aroundSave(db) {
            success = try updateOrInsertAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                selection: selection,
                fetch: fetch)
            return success!.saved
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(success.saved)
        return success.returned
    }
}
extension GRDB.MutablePersistableRecord {
  @inlinable internal mutating func updateOrInsertWithCallbacks(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?) throws -> GRDB.PersistenceSuccess {
        let (saved, _) = try updateOrInsertAndFetchWithCallbacks(
            db, onConflict: conflictResolution,
            selection: [],
            fetch: {
                // Nothing to fetch
                try $0.execute()
            })
        return saved
    }
  @inlinable internal mutating func updateOrInsertAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.PersistenceSuccess, T) {
        // Attempt at updating if the record has a primary key
        if let key = try primaryKey(db) {
            let databaseTableName = type(of: self).databaseTableName
            do {
                let columns = try Set(db.columns(in: databaseTableName).map(\.name))
                return try updateAndFetchWithCallbacks(
                    db, onConflict: conflictResolution,
                    columns: columns,
                    selection: selection,
                    fetch: fetch)
            } catch RecordError.recordNotFound(databaseTableName: databaseTableName, key: key) {
                // No row was updated: fallback on insert.
            }
        }
        
        // Insert
        let (inserted, returned) = try insertAndFetchWithCallbacks(
            db, onConflict: conflictResolution,
            selection: selection,
            fetch: fetch)
        return (PersistenceSuccess(inserted), returned)
    }
  @usableFromInline
  internal func primaryKey(_ db: GRDB.Database) throws -> [Swift.String : GRDB.DatabaseValue]?
}
public struct HasOneThroughAssociation<Origin, Destination> {
  public var _sqlAssociation: GRDB._SQLAssociation
}
extension GRDB.HasOneThroughAssociation : GRDB.AssociationToOne {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
}
public struct ResultCode : Swift.RawRepresentable, Swift.Equatable {
  public let rawValue: Swift.CInt
  public init(rawValue: Swift.CInt)
  public var primaryResultCode: GRDB.ResultCode {
    get
  }
  public static func ~= (pattern: GRDB.ResultCode, code: GRDB.ResultCode) -> Swift.Bool
  public static let SQLITE_OK: GRDB.ResultCode
  public static let SQLITE_ERROR: GRDB.ResultCode
  public static let SQLITE_INTERNAL: GRDB.ResultCode
  public static let SQLITE_PERM: GRDB.ResultCode
  public static let SQLITE_ABORT: GRDB.ResultCode
  public static let SQLITE_BUSY: GRDB.ResultCode
  public static let SQLITE_LOCKED: GRDB.ResultCode
  public static let SQLITE_NOMEM: GRDB.ResultCode
  public static let SQLITE_READONLY: GRDB.ResultCode
  public static let SQLITE_INTERRUPT: GRDB.ResultCode
  public static let SQLITE_IOERR: GRDB.ResultCode
  public static let SQLITE_CORRUPT: GRDB.ResultCode
  public static let SQLITE_NOTFOUND: GRDB.ResultCode
  public static let SQLITE_FULL: GRDB.ResultCode
  public static let SQLITE_CANTOPEN: GRDB.ResultCode
  public static let SQLITE_PROTOCOL: GRDB.ResultCode
  public static let SQLITE_EMPTY: GRDB.ResultCode
  public static let SQLITE_SCHEMA: GRDB.ResultCode
  public static let SQLITE_TOOBIG: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT: GRDB.ResultCode
  public static let SQLITE_MISMATCH: GRDB.ResultCode
  public static let SQLITE_MISUSE: GRDB.ResultCode
  public static let SQLITE_NOLFS: GRDB.ResultCode
  public static let SQLITE_AUTH: GRDB.ResultCode
  public static let SQLITE_FORMAT: GRDB.ResultCode
  public static let SQLITE_RANGE: GRDB.ResultCode
  public static let SQLITE_NOTADB: GRDB.ResultCode
  public static let SQLITE_NOTICE: GRDB.ResultCode
  public static let SQLITE_WARNING: GRDB.ResultCode
  public static let SQLITE_ROW: GRDB.ResultCode
  public static let SQLITE_DONE: GRDB.ResultCode
  public static let SQLITE_ERROR_MISSING_COLLSEQ: GRDB.ResultCode
  public static let SQLITE_ERROR_RETRY: GRDB.ResultCode
  public static let SQLITE_ERROR_SNAPSHOT: GRDB.ResultCode
  public static let SQLITE_IOERR_READ: GRDB.ResultCode
  public static let SQLITE_IOERR_SHORT_READ: GRDB.ResultCode
  public static let SQLITE_IOERR_WRITE: GRDB.ResultCode
  public static let SQLITE_IOERR_FSYNC: GRDB.ResultCode
  public static let SQLITE_IOERR_DIR_FSYNC: GRDB.ResultCode
  public static let SQLITE_IOERR_TRUNCATE: GRDB.ResultCode
  public static let SQLITE_IOERR_FSTAT: GRDB.ResultCode
  public static let SQLITE_IOERR_UNLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_RDLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_DELETE: GRDB.ResultCode
  public static let SQLITE_IOERR_BLOCKED: GRDB.ResultCode
  public static let SQLITE_IOERR_NOMEM: GRDB.ResultCode
  public static let SQLITE_IOERR_ACCESS: GRDB.ResultCode
  public static let SQLITE_IOERR_CHECKRESERVEDLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_LOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_CLOSE: GRDB.ResultCode
  public static let SQLITE_IOERR_DIR_CLOSE: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMOPEN: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMSIZE: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMMAP: GRDB.ResultCode
  public static let SQLITE_IOERR_SEEK: GRDB.ResultCode
  public static let SQLITE_IOERR_DELETE_NOENT: GRDB.ResultCode
  public static let SQLITE_IOERR_MMAP: GRDB.ResultCode
  public static let SQLITE_IOERR_GETTEMPPATH: GRDB.ResultCode
  public static let SQLITE_IOERR_CONVPATH: GRDB.ResultCode
  public static let SQLITE_IOERR_VNODE: GRDB.ResultCode
  public static let SQLITE_IOERR_AUTH: GRDB.ResultCode
  public static let SQLITE_IOERR_BEGIN_ATOMIC: GRDB.ResultCode
  public static let SQLITE_IOERR_COMMIT_ATOMIC: GRDB.ResultCode
  public static let SQLITE_IOERR_ROLLBACK_ATOMIC: GRDB.ResultCode
  public static let SQLITE_IOERR_DATA: GRDB.ResultCode
  public static let SQLITE_IOERR_CORRUPTFS: GRDB.ResultCode
  public static let SQLITE_LOCKED_SHAREDCACHE: GRDB.ResultCode
  public static let SQLITE_LOCKED_VTAB: GRDB.ResultCode
  public static let SQLITE_BUSY_RECOVERY: GRDB.ResultCode
  public static let SQLITE_BUSY_SNAPSHOT: GRDB.ResultCode
  public static let SQLITE_BUSY_TIMEOUT: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_NOTEMPDIR: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_ISDIR: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_FULLPATH: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_CONVPATH: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_DIRTYWAL: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_SYMLINK: GRDB.ResultCode
  public static let SQLITE_CORRUPT_VTAB: GRDB.ResultCode
  public static let SQLITE_CORRUPT_SEQUENCE: GRDB.ResultCode
  public static let SQLITE_CORRUPT_INDEX: GRDB.ResultCode
  public static let SQLITE_READONLY_RECOVERY: GRDB.ResultCode
  public static let SQLITE_READONLY_CANTLOCK: GRDB.ResultCode
  public static let SQLITE_READONLY_ROLLBACK: GRDB.ResultCode
  public static let SQLITE_READONLY_DBMOVED: GRDB.ResultCode
  public static let SQLITE_READONLY_CANTINIT: GRDB.ResultCode
  public static let SQLITE_READONLY_DIRECTORY: GRDB.ResultCode
  public static let SQLITE_ABORT_ROLLBACK: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_CHECK: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_COMMITHOOK: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_FOREIGNKEY: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_FUNCTION: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_NOTNULL: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_PRIMARYKEY: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_TRIGGER: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_UNIQUE: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_VTAB: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_ROWID: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_PINNED: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_DATATYPE: GRDB.ResultCode
  public static let SQLITE_NOTICE_RECOVER_WAL: GRDB.ResultCode
  public static let SQLITE_NOTICE_RECOVER_ROLLBACK: GRDB.ResultCode
  public static let SQLITE_WARNING_AUTOINDEX: GRDB.ResultCode
  public static let SQLITE_AUTH_USER: GRDB.ResultCode
  public static let SQLITE_OK_LOAD_PERMANENTLY: GRDB.ResultCode
  public static let SQLITE_OK_SYMLINK: GRDB.ResultCode
  public typealias RawValue = Swift.CInt
}
extension GRDB.ResultCode {
  public static func ~= (lhs: GRDB.ResultCode, rhs: any Swift.Error) -> Swift.Bool
}
extension GRDB.ResultCode : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension GRDB.ResultCode : Swift.Sendable {
}
public struct DatabaseError : Swift.Error {
  public var resultCode: GRDB.ResultCode {
    get
  }
  public let extendedResultCode: GRDB.ResultCode
  public let message: Swift.String?
  public let sql: Swift.String?
  public let arguments: GRDB.StatementArguments?
  public init(resultCode: GRDB.ResultCode = .SQLITE_ERROR, message: Swift.String? = nil, sql: Swift.String? = nil, arguments: GRDB.StatementArguments? = nil, publicStatementArguments: Swift.Bool = false)
  @usableFromInline
  internal init(resultCode: Swift.CInt, message: Swift.String? = nil, sql: Swift.String? = nil)
  @usableFromInline
  internal init(resultCode: Swift.CInt, message: Swift.String? = nil, sql: Swift.String? = nil, arguments: GRDB.StatementArguments?, publicStatementArguments: Swift.Bool)
}
extension GRDB.DatabaseError {
  public static let SQLITE_OK: GRDB.ResultCode
  public static let SQLITE_ERROR: GRDB.ResultCode
  public static let SQLITE_INTERNAL: GRDB.ResultCode
  public static let SQLITE_PERM: GRDB.ResultCode
  public static let SQLITE_ABORT: GRDB.ResultCode
  public static let SQLITE_BUSY: GRDB.ResultCode
  public static let SQLITE_LOCKED: GRDB.ResultCode
  public static let SQLITE_NOMEM: GRDB.ResultCode
  public static let SQLITE_READONLY: GRDB.ResultCode
  public static let SQLITE_INTERRUPT: GRDB.ResultCode
  public static let SQLITE_IOERR: GRDB.ResultCode
  public static let SQLITE_CORRUPT: GRDB.ResultCode
  public static let SQLITE_NOTFOUND: GRDB.ResultCode
  public static let SQLITE_FULL: GRDB.ResultCode
  public static let SQLITE_CANTOPEN: GRDB.ResultCode
  public static let SQLITE_PROTOCOL: GRDB.ResultCode
  public static let SQLITE_EMPTY: GRDB.ResultCode
  public static let SQLITE_SCHEMA: GRDB.ResultCode
  public static let SQLITE_TOOBIG: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT: GRDB.ResultCode
  public static let SQLITE_MISMATCH: GRDB.ResultCode
  public static let SQLITE_MISUSE: GRDB.ResultCode
  public static let SQLITE_NOLFS: GRDB.ResultCode
  public static let SQLITE_AUTH: GRDB.ResultCode
  public static let SQLITE_FORMAT: GRDB.ResultCode
  public static let SQLITE_RANGE: GRDB.ResultCode
  public static let SQLITE_NOTADB: GRDB.ResultCode
  public static let SQLITE_NOTICE: GRDB.ResultCode
  public static let SQLITE_WARNING: GRDB.ResultCode
  public static let SQLITE_ROW: GRDB.ResultCode
  public static let SQLITE_DONE: GRDB.ResultCode
  public static let SQLITE_ERROR_MISSING_COLLSEQ: GRDB.ResultCode
  public static let SQLITE_ERROR_RETRY: GRDB.ResultCode
  public static let SQLITE_ERROR_SNAPSHOT: GRDB.ResultCode
  public static let SQLITE_IOERR_READ: GRDB.ResultCode
  public static let SQLITE_IOERR_SHORT_READ: GRDB.ResultCode
  public static let SQLITE_IOERR_WRITE: GRDB.ResultCode
  public static let SQLITE_IOERR_FSYNC: GRDB.ResultCode
  public static let SQLITE_IOERR_DIR_FSYNC: GRDB.ResultCode
  public static let SQLITE_IOERR_TRUNCATE: GRDB.ResultCode
  public static let SQLITE_IOERR_FSTAT: GRDB.ResultCode
  public static let SQLITE_IOERR_UNLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_RDLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_DELETE: GRDB.ResultCode
  public static let SQLITE_IOERR_BLOCKED: GRDB.ResultCode
  public static let SQLITE_IOERR_NOMEM: GRDB.ResultCode
  public static let SQLITE_IOERR_ACCESS: GRDB.ResultCode
  public static let SQLITE_IOERR_CHECKRESERVEDLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_LOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_CLOSE: GRDB.ResultCode
  public static let SQLITE_IOERR_DIR_CLOSE: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMOPEN: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMSIZE: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMLOCK: GRDB.ResultCode
  public static let SQLITE_IOERR_SHMMAP: GRDB.ResultCode
  public static let SQLITE_IOERR_SEEK: GRDB.ResultCode
  public static let SQLITE_IOERR_DELETE_NOENT: GRDB.ResultCode
  public static let SQLITE_IOERR_MMAP: GRDB.ResultCode
  public static let SQLITE_IOERR_GETTEMPPATH: GRDB.ResultCode
  public static let SQLITE_IOERR_CONVPATH: GRDB.ResultCode
  public static let SQLITE_IOERR_VNODE: GRDB.ResultCode
  public static let SQLITE_IOERR_AUTH: GRDB.ResultCode
  public static let SQLITE_IOERR_BEGIN_ATOMIC: GRDB.ResultCode
  public static let SQLITE_IOERR_COMMIT_ATOMIC: GRDB.ResultCode
  public static let SQLITE_IOERR_ROLLBACK_ATOMIC: GRDB.ResultCode
  public static let SQLITE_IOERR_DATA: GRDB.ResultCode
  public static let SQLITE_IOERR_CORRUPTFS: GRDB.ResultCode
  public static let SQLITE_LOCKED_SHAREDCACHE: GRDB.ResultCode
  public static let SQLITE_LOCKED_VTAB: GRDB.ResultCode
  public static let SQLITE_BUSY_RECOVERY: GRDB.ResultCode
  public static let SQLITE_BUSY_SNAPSHOT: GRDB.ResultCode
  public static let SQLITE_BUSY_TIMEOUT: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_NOTEMPDIR: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_ISDIR: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_FULLPATH: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_CONVPATH: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_DIRTYWAL: GRDB.ResultCode
  public static let SQLITE_CANTOPEN_SYMLINK: GRDB.ResultCode
  public static let SQLITE_CORRUPT_VTAB: GRDB.ResultCode
  public static let SQLITE_CORRUPT_SEQUENCE: GRDB.ResultCode
  public static let SQLITE_CORRUPT_INDEX: GRDB.ResultCode
  public static let SQLITE_READONLY_RECOVERY: GRDB.ResultCode
  public static let SQLITE_READONLY_CANTLOCK: GRDB.ResultCode
  public static let SQLITE_READONLY_ROLLBACK: GRDB.ResultCode
  public static let SQLITE_READONLY_DBMOVED: GRDB.ResultCode
  public static let SQLITE_READONLY_CANTINIT: GRDB.ResultCode
  public static let SQLITE_READONLY_DIRECTORY: GRDB.ResultCode
  public static let SQLITE_ABORT_ROLLBACK: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_CHECK: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_COMMITHOOK: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_FOREIGNKEY: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_FUNCTION: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_NOTNULL: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_PRIMARYKEY: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_TRIGGER: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_UNIQUE: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_VTAB: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_ROWID: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_PINNED: GRDB.ResultCode
  public static let SQLITE_CONSTRAINT_DATATYPE: GRDB.ResultCode
  public static let SQLITE_NOTICE_RECOVER_WAL: GRDB.ResultCode
  public static let SQLITE_NOTICE_RECOVER_ROLLBACK: GRDB.ResultCode
  public static let SQLITE_WARNING_AUTOINDEX: GRDB.ResultCode
  public static let SQLITE_AUTH_USER: GRDB.ResultCode
  public static let SQLITE_OK_LOAD_PERMANENTLY: GRDB.ResultCode
  public static let SQLITE_OK_SYMLINK: GRDB.ResultCode
}
extension GRDB.DatabaseError {
  public var isInterruptionError: Swift.Bool {
    get
  }
}
extension GRDB.DatabaseError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var expandedDescription: Swift.String {
    get
  }
}
extension GRDB.DatabaseError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public struct ForeignKey : Swift.Equatable {
  public init(_ originColumns: [Swift.String], to destinationColumns: [Swift.String]? = nil)
  public init(_ originColumns: [any GRDB.ColumnExpression], to destinationColumns: [any GRDB.ColumnExpression]? = nil)
  public static func == (a: GRDB.ForeignKey, b: GRDB.ForeignKey) -> Swift.Bool
}
extension GRDB.FetchableRecord where Self : GRDB.TableRecord {
  public static func fetchCursor(_ db: GRDB.Database) throws -> GRDB.RecordCursor<Self>
  public static func fetchAll(_ db: GRDB.Database) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database) throws -> Self?
}
extension GRDB.FetchableRecord where Self : GRDB.TableRecord, Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<Self>
}
extension GRDB.FetchableRecord where Self : GRDB.TableRecord {
  public static func fetchCursor<Keys>(_ db: GRDB.Database, keys: Keys) throws -> GRDB.RecordCursor<Self> where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
  public static func fetchAll<Keys>(_ db: GRDB.Database, keys: Keys) throws -> [Self] where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
  public static func fetchOne(_ db: GRDB.Database, key: some DatabaseValueConvertible) throws -> Self?
  public static func find(_ db: GRDB.Database, key: some DatabaseValueConvertible) throws -> Self
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.FetchableRecord where Self : GRDB.TableRecord, Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  public static func fetchCursor<IDS>(_ db: GRDB.Database, ids: IDS) throws -> GRDB.RecordCursor<Self> where IDS : Swift.Collection, Self.ID == IDS.Element
  public static func fetchAll<IDS>(_ db: GRDB.Database, ids: IDS) throws -> [Self] where IDS : Swift.Collection, Self.ID == IDS.Element
  public static func fetchOne(_ db: GRDB.Database, id: Self.ID) throws -> Self?
  public static func find(_ db: GRDB.Database, id: Self.ID) throws -> Self
}
extension GRDB.FetchableRecord where Self : GRDB.TableRecord, Self : Swift.Hashable {
  public static func fetchSet<Keys>(_ db: GRDB.Database, keys: Keys) throws -> Swift.Set<Self> where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.FetchableRecord where Self : GRDB.TableRecord, Self : Swift.Hashable, Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  public static func fetchSet<IDS>(_ db: GRDB.Database, ids: IDS) throws -> Swift.Set<Self> where IDS : Swift.Collection, Self.ID == IDS.Element
}
extension GRDB.FetchableRecord where Self : GRDB.TableRecord {
  public static func fetchCursor(_ db: GRDB.Database, keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) throws -> GRDB.RecordCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]?) throws -> Self?
  public static func find(_ db: GRDB.Database, key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]) throws -> Self
}
extension GRDB.FetchableRecord where Self : GRDB.TableRecord, Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) throws -> Swift.Set<Self>
}
public protocol PersistableRecord : GRDB.MutablePersistableRecord {
  func willInsert(_ db: GRDB.Database) throws
  func didInsert(_ inserted: GRDB.InsertionSuccess)
}
public protocol Association : GRDB.DerivableRequest {
  associatedtype OriginRowDecoder
  var _sqlAssociation: GRDB._SQLAssociation { get set }
  func forKey(_ key: Swift.String) -> Self
}
extension GRDB.Association {
  public func _including(all association: GRDB._SQLAssociation) -> Self
  public func _including(optional association: GRDB._SQLAssociation) -> Self
  public func _including(required association: GRDB._SQLAssociation) -> Self
  public func _joining(optional association: GRDB._SQLAssociation) -> Self
  public func _joining(required association: GRDB._SQLAssociation) -> Self
}
extension GRDB.Association {
  public func forKey(_ codingKey: some CodingKey) -> Self
}
extension GRDB.Association {
  public func aliased(_ alias: GRDB.TableAlias) -> Self
}
extension GRDB.Association {
  public func selectWhenConnected(_ selection: @escaping (GRDB.Database) throws -> [any GRDB.SQLSelectable]) -> Self
  public func annotatedWhenConnected(with selection: @escaping (GRDB.Database) throws -> [any GRDB.SQLSelectable]) -> Self
}
extension GRDB.Association {
  public func filterWhenConnected(_ predicate: @escaping (GRDB.Database) throws -> any GRDB.SQLExpressible) -> Self
}
extension GRDB.Association {
  public func orderWhenConnected(_ orderings: @escaping (GRDB.Database) throws -> [any GRDB.SQLOrderingTerm]) -> Self
  public func reversed() -> Self
  public func unordered() -> Self
}
extension GRDB.Association {
  public var databaseTableName: Swift.String {
    get
  }
}
extension GRDB.Association {
  public func groupWhenConnected(_ expressions: @escaping (GRDB.Database) throws -> [any GRDB.SQLExpressible]) -> Self
  public func havingWhenConnected(_ predicate: @escaping (GRDB.Database) throws -> any GRDB.SQLExpressible) -> Self
}
extension GRDB.Association {
  public func distinct() -> Self
  public func with<RowDecoder>(_ cte: GRDB.CommonTableExpression<RowDecoder>) -> Self
}
public protocol AssociationToOne : GRDB.Association {
}
extension GRDB.AssociationToOne {
  public func forKey(_ key: Swift.String) -> Self
}
public protocol AssociationToMany : GRDB.Association {
}
extension GRDB.AssociationToMany {
  public func forKey(_ key: Swift.String) -> Self
}
public struct DatabaseValue : Swift.Hashable {
  public let storage: GRDB.DatabaseValue.Storage
  public static let null: GRDB.DatabaseValue
  @frozen public enum Storage {
    case null
    case int64(Swift.Int64)
    case double(Swift.Double)
    case string(Swift.String)
    case blob(Foundation.Data)
    public var value: (any GRDB.DatabaseValueConvertible)? {
      get
    }
  }
  public init?(value: Any)
  public var isNull: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension GRDB.DatabaseValue : GRDB.StatementBinding {
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension GRDB.DatabaseValue : Swift.Sendable {
}
extension GRDB.DatabaseValue.Storage : @unchecked Swift.Sendable {
}
extension GRDB.DatabaseValue.Storage : Swift.Equatable {
  public static func == (lhs: GRDB.DatabaseValue.Storage, rhs: GRDB.DatabaseValue.Storage) -> Swift.Bool
}
extension GRDB.DatabaseValue : Swift.Equatable {
  public static func == (lhs: GRDB.DatabaseValue, rhs: GRDB.DatabaseValue) -> Swift.Bool
}
extension GRDB.DatabaseValue {
  public func hash(into hasher: inout Swift.Hasher)
}
extension GRDB.DatabaseValue : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> GRDB.DatabaseValue?
}
extension GRDB.DatabaseValue : GRDB.SQLSpecificExpressible {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
extension GRDB.DatabaseValue : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct FTS3TokenizerDescriptor {
  public static let simple: GRDB.FTS3TokenizerDescriptor
  public static let porter: GRDB.FTS3TokenizerDescriptor
  public static func unicode61(diacritics: GRDB.FTS3.Diacritics = .removeLegacy, separators: Swift.Set<Swift.Character> = [], tokenCharacters: Swift.Set<Swift.Character> = []) -> GRDB.FTS3TokenizerDescriptor
}
open class Record {
  public init()
  required public init(row: GRDB.Row) throws
  open class var databaseTableName: Swift.String {
    get
  }
  open class var persistenceConflictPolicy: GRDB.PersistenceConflictPolicy {
    get
  }
  open class var databaseSelection: [any GRDB.SQLSelectable] {
    get
  }
  open func encode(to container: inout GRDB.PersistenceContainer) throws
  public var hasDatabaseChanges: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $EffectfulProp
  public var databaseChanges: [Swift.String : GRDB.DatabaseValue?] {
    get throws
  }
  #endif
  open func willInsert(_ db: GRDB.Database) throws
  open func aroundInsert(_ db: GRDB.Database, insert: () throws -> GRDB.InsertionSuccess) throws
  open func didInsert(_ inserted: GRDB.InsertionSuccess)
  open func willUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>) throws
  open func aroundUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>, update: () throws -> GRDB.PersistenceSuccess) throws
  open func didUpdate(_ updated: GRDB.PersistenceSuccess)
  open func willSave(_ db: GRDB.Database) throws
  open func aroundSave(_ db: GRDB.Database, save: () throws -> GRDB.PersistenceSuccess) throws
  open func didSave(_ saved: GRDB.PersistenceSuccess)
  open func willDelete(_ db: GRDB.Database) throws
  open func aroundDelete(_ db: GRDB.Database, delete: () throws -> Swift.Bool) throws
  open func didDelete(deleted: Swift.Bool)
  @discardableResult
  final public func updateChanges(_ db: GRDB.Database) throws -> Swift.Bool
  @objc deinit
}
extension GRDB.Record : GRDB.TableRecord {
}
extension GRDB.Record : GRDB.PersistableRecord {
}
extension GRDB.Record : GRDB.FetchableRecord {
}
public protocol ColumnExpression : GRDB.SQLSpecificExpressible {
  var name: Swift.String { get }
}
extension GRDB.ColumnExpression {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
  public var detached: GRDB.SQLExpression {
    get
  }
}
extension GRDB.ColumnExpression where Self == GRDB.Column {
  public static var rowID: GRDB.Column {
    get
  }
}
public struct Column {
  public static let rowID: GRDB.Column
  public var name: Swift.String
  public init(_ name: Swift.String)
  public init(_ codingKey: some CodingKey)
}
extension GRDB.Column : GRDB.ColumnExpression {
}
extension GRDB.ColumnExpression where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
extension Foundation.NSURL : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
extension Foundation.URL : GRDB.DatabaseValueConvertible {
}
public protocol TableRecord {
  static var databaseTableName: Swift.String { get }
  static var databaseSelection: [any GRDB.SQLSelectable] { get }
}
extension GRDB.TableRecord {
  public static var databaseTableName: Swift.String {
    get
  }
  public static var databaseSelection: [any GRDB.SQLSelectable] {
    get
  }
}
extension GRDB.TableRecord {
  public static func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
}
extension GRDB.TableRecord {
  public static func numberOfSelectedColumns(_ db: GRDB.Database) throws -> Swift.Int
}
extension GRDB.TableRecord {
  @discardableResult
  public static func deleteAll(_ db: GRDB.Database) throws -> Swift.Int
}
extension GRDB.TableRecord {
  public static func exists(_ db: GRDB.Database, key: some DatabaseValueConvertible) throws -> Swift.Bool
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.TableRecord where Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  public static func exists(_ db: GRDB.Database, id: Self.ID) throws -> Swift.Bool
}
extension GRDB.TableRecord {
  public static func exists(_ db: GRDB.Database, key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]) throws -> Swift.Bool
}
extension GRDB.TableRecord {
  @discardableResult
  public static func deleteAll<Keys>(_ db: GRDB.Database, keys: Keys) throws -> Swift.Int where Keys : Swift.Sequence, Keys.Element : GRDB.DatabaseValueConvertible
  @discardableResult
  public static func deleteOne(_ db: GRDB.Database, key: some DatabaseValueConvertible) throws -> Swift.Bool
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.TableRecord where Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  @discardableResult
  public static func deleteAll<IDS>(_ db: GRDB.Database, ids: IDS) throws -> Swift.Int where IDS : Swift.Collection, Self.ID == IDS.Element
  @discardableResult
  public static func deleteOne(_ db: GRDB.Database, id: Self.ID) throws -> Swift.Bool
}
extension GRDB.TableRecord {
  @discardableResult
  public static func deleteAll(_ db: GRDB.Database, keys: [[Swift.String : (any GRDB.DatabaseValueConvertible)?]]) throws -> Swift.Int
  @discardableResult
  public static func deleteOne(_ db: GRDB.Database, key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]) throws -> Swift.Bool
}
extension GRDB.TableRecord {
  @discardableResult
  public static func updateAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: [GRDB.ColumnAssignment]) throws -> Swift.Int
  @discardableResult
  public static func updateAll(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, _ assignments: GRDB.ColumnAssignment...) throws -> Swift.Int
}
public enum RecordError : Swift.Error {
  case recordNotFound(databaseTableName: Swift.String, key: [Swift.String : GRDB.DatabaseValue])
}
extension GRDB.RecordError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension GRDB.TableRecord {
  public static func recordNotFound(_ db: GRDB.Database, key: some DatabaseValueConvertible) -> any Swift.Error
  public static func recordNotFound(key: [Swift.String : (any GRDB.DatabaseValueConvertible)?]) -> GRDB.RecordError
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.TableRecord where Self : Swift.Identifiable, Self.ID : GRDB.DatabaseValueConvertible {
  public static func recordNotFound(_ db: GRDB.Database, id: Self.ID) -> any Swift.Error
}
@available(*, deprecated, renamed: "RecordError")
public typealias PersistenceError = GRDB.RecordError
extension Swift.RangeReplaceableCollection {
  public init(_ cursor: some Cursor<Element>) throws
  public init(_ cursor: some Cursor<Element>, minimumCapacity: Swift.Int) throws
  public mutating func append(contentsOf newElements: some Cursor<Element>) throws
}
extension Swift.Dictionary {
  public init<C>(grouping cursor: C, by keyForValue: (C.Element) throws -> Key) throws where Value == [C.Element], C : GRDB.Cursor
  public init<C>(minimumCapacity: Swift.Int, grouping cursor: C, by keyForValue: (C.Element) throws -> Key) throws where Value == [C.Element], C : GRDB.Cursor
  public init(uniqueKeysWithValues keysAndValues: some Cursor<(Key, Value)>) throws
  public init(minimumCapacity: Swift.Int, uniqueKeysWithValues keysAndValues: some Cursor<(Key, Value)>) throws
}
extension Swift.Set {
  public init(_ cursor: some Cursor<Element>) throws
  public init(_ cursor: some Cursor<Element>, minimumCapacity: Swift.Int) throws
}
extension Swift.Sequence {
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Iterator.Element) throws -> SegmentOfResult) -> GRDB.FlattenCursor<GRDB.MapCursor<GRDB.AnyCursor<Self.Iterator.Element>, SegmentOfResult>> where SegmentOfResult : GRDB.Cursor
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol Cursor<Element> : AnyObject {
  associatedtype Element
  func next() throws -> Self.Element?
  func forEach(_ body: (Self.Element) throws -> Swift.Void) throws
}
#else
public protocol Cursor : AnyObject {
  associatedtype Element
  func next() throws -> Self.Element?
  func forEach(_ body: (Self.Element) throws -> Swift.Void) throws
}
#endif
extension GRDB.Cursor {
  #if compiler(>=5.3) && $EffectfulProp
  public var isEmpty: Swift.Bool {
    get throws
  }
  #endif
  public func contains(where predicate: (Self.Element) throws -> Swift.Bool) throws -> Swift.Bool
  public func enumerated() -> GRDB.EnumeratedCursor<Self>
  public func filter(_ isIncluded: @escaping (Self.Element) throws -> Swift.Bool) -> GRDB.FilterCursor<Self>
  public func first(where predicate: (Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Element) throws -> ElementOfResult?) -> GRDB.MapCursor<GRDB.FilterCursor<GRDB.MapCursor<Self, ElementOfResult?>>, ElementOfResult>
  public func drop(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> GRDB.DropWhileCursor<Self>
  public func dropFirst(_ n: Swift.Int) -> GRDB.DropFirstCursor<Self>
  public func dropFirst() -> GRDB.DropFirstCursor<Self>
  public func dropLast(_ n: Swift.Int) throws -> [Self.Element]
  public func dropLast() throws -> [Self.Element]
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) throws -> SegmentOfResult) -> GRDB.FlattenCursor<GRDB.MapCursor<Self, GRDB.AnyCursor<SegmentOfResult.Element>>> where SegmentOfResult : Swift.Sequence
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) throws -> SegmentOfResult) -> GRDB.FlattenCursor<GRDB.MapCursor<Self, SegmentOfResult>> where SegmentOfResult : GRDB.Cursor
  public func forEach(_ body: (Self.Element) throws -> Swift.Void) throws
  public func map<T>(_ transform: @escaping (Self.Element) throws -> T) -> GRDB.MapCursor<Self, T>
  public func max(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func min(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func prefix(_ maxLength: Swift.Int) -> GRDB.PrefixCursor<Self>
  public func prefix(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> GRDB.PrefixWhileCursor<Self>
  public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Self.Element) throws -> Result) throws -> Result
  public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Self.Element) throws -> Swift.Void) throws -> Result
  public func suffix(_ maxLength: Swift.Int) throws -> [Self.Element]
}
extension GRDB.Cursor where Self.Element : Swift.Equatable {
  public func contains(_ element: Self.Element) throws -> Swift.Bool
}
extension GRDB.Cursor where Self.Element : Swift.Comparable {
  public func max() throws -> Self.Element?
  public func min() throws -> Self.Element?
}
extension GRDB.Cursor where Self.Element : GRDB.Cursor {
  public func joined() -> GRDB.FlattenCursor<Self>
}
extension GRDB.Cursor where Self.Element : Swift.Sequence {
  public func joined() -> GRDB.FlattenCursor<GRDB.MapCursor<Self, GRDB.AnyCursor<Self.Element.Element>>>
}
extension GRDB.Cursor where Self.Element : Swift.StringProtocol {
  public func joined(separator: Swift.String = "") throws -> Swift.String
}
final public class AnyCursor<Element> : GRDB.Cursor {
  public init<C>(_ base: C) where Element == C.Element, C : GRDB.Cursor
  convenience public init<I>(iterator: I) where Element == I.Element, I : Swift.IteratorProtocol
  convenience public init<S>(_ sequence: S) where Element == S.Element, S : Swift.Sequence
  public init(_ next: @escaping () throws -> Element?)
  final public func next() throws -> Element?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DropFirstCursor<Base> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.DropFirstCursor : GRDB.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
}
@_hasMissingDesignatedInitializers final public class DropWhileCursor<Base> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.DropWhileCursor : GRDB.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
}
@_hasMissingDesignatedInitializers final public class EnumeratedCursor<Base> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.EnumeratedCursor : GRDB.Cursor {
  final public func next() throws -> (Swift.Int, Base.Element)?
  final public func forEach(_ body: ((Swift.Int, Base.Element)) throws -> Swift.Void) throws
  public typealias Element = (Swift.Int, Base.Element)
}
@_hasMissingDesignatedInitializers final public class FilterCursor<Base> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.FilterCursor : GRDB.Cursor {
  final public func next() throws -> Base.Element?
  final public func forEach(_ body: (Base.Element) throws -> Swift.Void) throws
  public typealias Element = Base.Element
}
@_hasMissingDesignatedInitializers final public class FlattenCursor<Base> where Base : GRDB.Cursor, Base.Element : GRDB.Cursor {
  @objc deinit
}
extension GRDB.FlattenCursor : GRDB.Cursor {
  final public func next() throws -> Base.Element.Element?
  public typealias Element = Base.Element.Element
}
@_hasMissingDesignatedInitializers final public class MapCursor<Base, Element> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.MapCursor : GRDB.Cursor {
  final public func next() throws -> Element?
  final public func forEach(_ body: (Element) throws -> Swift.Void) throws
}
@_hasMissingDesignatedInitializers final public class PrefixCursor<Base> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.PrefixCursor : GRDB.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
}
@_hasMissingDesignatedInitializers final public class PrefixWhileCursor<Base> where Base : GRDB.Cursor {
  @objc deinit
}
extension GRDB.PrefixWhileCursor : GRDB.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
}
public protocol TransactionClock {
  func now(_ db: GRDB.Database) throws -> Foundation.Date
}
extension GRDB.TransactionClock where Self == GRDB.DefaultTransactionClock {
  public static var `default`: GRDB.DefaultTransactionClock {
    get
  }
}
extension GRDB.TransactionClock where Self == GRDB.CustomTransactionClock {
  public static func custom(_ now: @escaping (GRDB.Database) throws -> Foundation.Date) -> Self
}
public struct DefaultTransactionClock : GRDB.TransactionClock {
  public func now(_ db: GRDB.Database) throws -> Foundation.Date
}
public struct CustomTransactionClock : GRDB.TransactionClock {
  public init(_ now: @escaping (GRDB.Database) throws -> Foundation.Date)
  public func now(_ db: GRDB.Database) throws -> Foundation.Date
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Encodable {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Encodable, Self : Swift.RawRepresentable, Self.RawValue : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
}
public struct HasManyThroughAssociation<Origin, Destination> {
  public var _sqlAssociation: GRDB._SQLAssociation
}
extension GRDB.HasManyThroughAssociation : GRDB.AssociationToMany {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
}
final public class DatabasePool {
  final public var configuration: GRDB.Configuration {
    get
  }
  final public var path: Swift.String {
    get
  }
  public init(path: Swift.String, configuration: GRDB.Configuration = Configuration()) throws
  @objc deinit
}
extension GRDB.DatabasePool : @unchecked Swift.Sendable {
}
extension GRDB.DatabasePool {
  final public func releaseMemory()
  final public func releaseMemoryEventually()
}
extension GRDB.DatabasePool : GRDB.DatabaseReader {
  final public func close() throws
  final public func interrupt()
  @_disfavoredOverload final public func read<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  @_disfavoredOverload final public func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func concurrentRead<T>(_ value: @escaping (GRDB.Database) throws -> T) -> GRDB.DatabaseFuture<T>
  final public func spawnConcurrentRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func asyncConcurrentRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func invalidateReadOnlyConnections()
  final public func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
extension GRDB.DatabasePool : GRDB.DatabaseWriter {
  @_disfavoredOverload final public func writeWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  @_disfavoredOverload final public func barrierWriteWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) throws -> T
  final public func asyncBarrierWriteWithoutTransaction(_ updates: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func writeInTransaction(_ kind: GRDB.Database.TransactionKind? = nil, _ updates: (GRDB.Database) throws -> GRDB.Database.TransactionCompletion) throws
  final public func unsafeReentrantWrite<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  final public func asyncWriteWithoutTransaction(_ updates: @escaping (GRDB.Database) -> Swift.Void)
}
extension GRDB.DatabasePool {
  final public func makeSnapshot() throws -> GRDB.DatabaseSnapshot
  final public func makeSnapshotPool() throws -> GRDB.DatabaseSnapshotPool
}
extension GRDB.ValueObservation {
  public func map<T>(_ transform: @escaping (Reducer.Value) throws -> T) -> GRDB.ValueObservation<GRDB.ValueReducers.Map<Reducer, T>>
}
extension GRDB.ValueReducers {
  public struct Map<Base, Value> : GRDB._ValueReducer where Base : GRDB._ValueReducer {
    public mutating func _value(_ fetched: Base.Fetched) throws -> Value?
    public typealias Fetched = Base.Fetched
  }
}
extension GRDB.ValueReducers.Map : GRDB.ValueReducer where Base : GRDB.ValueReducer {
  public func _fetch(_ db: GRDB.Database) throws -> Base.Fetched
}
public typealias SQLiteStatement = Swift.OpaquePointer
@_hasMissingDesignatedInitializers final public class Statement {
  final public let sqliteStatement: GRDB.SQLiteStatement
  final public var sql: Swift.String {
    get
  }
  final public var columnNames: [Swift.String] {
    get
    set
  }
  final public var databaseRegion: GRDB.DatabaseRegion {
    get
  }
  final public var isReadonly: Swift.Bool {
    get
  }
  @usableFromInline
  unowned final internal let database: GRDB.Database
  @objc deinit
  final public var arguments: GRDB.StatementArguments {
    get
    set
  }
  final public func validateArguments(_ arguments: GRDB.StatementArguments) throws
  final public func setUncheckedArguments(_ arguments: GRDB.StatementArguments)
  final public func setArguments(_ arguments: GRDB.StatementArguments) throws
  final public func execute(arguments: GRDB.StatementArguments? = nil) throws
  @usableFromInline
  final internal func forEachStep(_ body: (GRDB.SQLiteStatement) throws -> Swift.Void) throws
  @usableFromInline
  final internal func step<T>(_ body: (GRDB.SQLiteStatement) throws -> T) throws -> T?
}
extension GRDB.Statement : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension GRDB.Statement {
  final public var columnCount: Swift.Int {
    get
  }
  final public func index(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol DatabaseCursor : GRDB.Cursor {
  var _isDone: Swift.Bool { get set }
  var _statement: GRDB.Statement { get }
  func _element(sqliteStatement: GRDB.SQLiteStatement) throws -> Self.Element
}
extension GRDB.DatabaseCursor {
  public var sql: Swift.String {
    get
  }
  public var arguments: GRDB.StatementArguments {
    get
  }
  public var columnNames: [Swift.String] {
    get
  }
  public var columnCount: Swift.Int {
    get
  }
  public var databaseRegion: GRDB.DatabaseRegion {
    get
  }
}
extension GRDB.DatabaseCursor {
  @inlinable public func next() throws -> Self.Element? {
        if _isDone {
            return nil
        }
        if let element = try _statement.step(_element) {
            return element
        }
        _isDone = true
        return nil
    }
  @inlinable public func forEach(_ body: (Self.Element) throws -> Swift.Void) throws {
        if _isDone { return }
        try _statement.forEachStep {
            try body(_element(sqliteStatement: $0))
        }
        _isDone = true
    }
}
public protocol StatementBinding {
  func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
@usableFromInline
internal func withBindings<C, T>(_ bindings: C, to sqliteStatement: GRDB.SQLiteStatement, from index: Swift.CInt = 1, do body: () throws -> T) throws -> T where C : Swift.Collection, C.Element == GRDB.DatabaseValue
public struct StatementArguments : Swift.Hashable {
  public var isEmpty: Swift.Bool {
    get
  }
  public init()
  public init<S>(_ sequence: S) where S : Swift.Sequence, S.Element == (any GRDB.DatabaseValueConvertible)?
  public init<S>(_ sequence: S) where S : Swift.Sequence, S.Element : GRDB.DatabaseValueConvertible
  public init?(_ array: [Any])
  public init(_ dictionary: [Swift.String : (any GRDB.DatabaseValueConvertible)?])
  public init<S>(_ sequence: S) where S : Swift.Sequence, S.Element == (Swift.String, (any GRDB.DatabaseValueConvertible)?)
  public init?(_ dictionary: [Swift.AnyHashable : Any])
  public mutating func append(contentsOf arguments: GRDB.StatementArguments) -> [Swift.String : GRDB.DatabaseValue]
  public static func + (lhs: GRDB.StatementArguments, rhs: GRDB.StatementArguments) -> GRDB.StatementArguments
  public static func &+ (lhs: GRDB.StatementArguments, rhs: GRDB.StatementArguments) -> GRDB.StatementArguments
  public static func += (lhs: inout GRDB.StatementArguments, rhs: GRDB.StatementArguments)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: GRDB.StatementArguments, b: GRDB.StatementArguments) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension GRDB.StatementArguments : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: (any GRDB.DatabaseValueConvertible)?...)
  public typealias ArrayLiteralElement = (any GRDB.DatabaseValueConvertible)?
}
extension GRDB.StatementArguments : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, (any GRDB.DatabaseValueConvertible)?)...)
  public typealias Key = Swift.String
  public typealias Value = (any GRDB.DatabaseValueConvertible)?
}
extension GRDB.StatementArguments : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension GRDB.StatementArguments : Swift.Sendable {
}
extension GRDB.TableRecord {
  public static func belongsTo<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.BelongsToAssociation<Self, Destination> where Destination : GRDB.TableRecord
  public static func hasMany<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasManyAssociation<Self, Destination> where Destination : GRDB.TableRecord
  public static func hasOne<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasOneAssociation<Self, Destination> where Destination : GRDB.TableRecord
}
extension GRDB.TableRecord {
  public static func belongsTo<Destination>(_ destination: GRDB.Table<Destination>, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.BelongsToAssociation<Self, Destination>
  public static func hasMany<Destination>(_ destination: GRDB.Table<Destination>, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasManyAssociation<Self, Destination>
  public static func hasOne<Destination>(_ destination: GRDB.Table<Destination>, key: Swift.String? = nil, using foreignKey: GRDB.ForeignKey? = nil) -> GRDB.HasOneAssociation<Self, Destination>
}
extension GRDB.TableRecord {
  public static func association<Destination>(to cte: GRDB.CommonTableExpression<Destination>, on condition: @escaping (_ left: GRDB.TableAlias, _ right: GRDB.TableAlias) -> any GRDB.SQLExpressible) -> GRDB.JoinAssociation<Self, Destination>
  public static func association<Destination>(to cte: GRDB.CommonTableExpression<Destination>) -> GRDB.JoinAssociation<Self, Destination>
}
extension GRDB.TableRecord {
  public static func hasMany<Pivot, Target>(_ destination: Target.RowDecoder.Type, through pivot: Pivot, using target: Target, key: Swift.String? = nil) -> GRDB.HasManyThroughAssociation<Self, Target.RowDecoder> where Self == Pivot.OriginRowDecoder, Pivot : GRDB.Association, Target : GRDB.Association, Pivot.RowDecoder == Target.OriginRowDecoder
  public static func hasOne<Pivot, Target>(_ destination: Target.RowDecoder.Type, through pivot: Pivot, using target: Target, key: Swift.String? = nil) -> GRDB.HasOneThroughAssociation<Self, Target.RowDecoder> where Self == Pivot.OriginRowDecoder, Pivot : GRDB.AssociationToOne, Target : GRDB.AssociationToOne, Pivot.RowDecoder == Target.OriginRowDecoder
}
extension GRDB.TableRecord where Self : GRDB.EncodableRecord {
  public func request<A>(for association: A) -> GRDB.QueryInterfaceRequest<A.RowDecoder> where Self == A.OriginRowDecoder, A : GRDB.Association
}
extension GRDB.TableRecord {
  public static func including<A>(all association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.AssociationToMany
  public static func including<A>(optional association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.Association
  public static func including<A>(required association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.Association
  public static func joining<A>(optional association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.Association
  public static func joining<A>(required association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.Association
  public static func annotated<A>(withOptional association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.Association
  public static func annotated<A>(withRequired association: A) -> GRDB.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : GRDB.Association
}
extension GRDB.TableRecord {
  public static func annotated(with aggregates: GRDB.AssociationAggregate<Self>...) -> GRDB.QueryInterfaceRequest<Self>
  public static func annotated(with aggregates: [GRDB.AssociationAggregate<Self>]) -> GRDB.QueryInterfaceRequest<Self>
  public static func having(_ predicate: GRDB.AssociationAggregate<Self>) -> GRDB.QueryInterfaceRequest<Self>
}
extension GRDB.MutablePersistableRecord {
  @inline(__always) @inlinable public func willUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>) throws { }
  @inline(__always) @inlinable public func aroundUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>, update: () throws -> GRDB.PersistenceSuccess) throws {
        _ = try update()
    }
  @inline(__always) @inlinable public func didUpdate(_ updated: GRDB.PersistenceSuccess) { }
}
extension GRDB.MutablePersistableRecord {
  @inlinable public func update<Columns>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, columns: Columns) throws where Columns : Swift.Sequence, Columns.Element == Swift.String {
        try willSave(db)
        
        var updated: PersistenceSuccess?
        try aroundSave(db) {
            updated = try updateWithCallbacks(db, onConflict: conflictResolution, columns: Set(columns))
            return updated!
        }
        
        guard let updated else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(updated)
    }
  @inlinable public func update<Columns>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, columns: Columns) throws where Columns : Swift.Sequence, Columns.Element : GRDB.ColumnExpression {
        try update(db, onConflict: conflictResolution, columns: columns.map(\.name))
    }
  @inlinable public func update(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws {
        let databaseTableName = type(of: self).databaseTableName
        let columns = try db.columns(in: databaseTableName).map(\.name)
        try update(db, onConflict: conflictResolution, columns: columns)
    }
  @discardableResult
  @inlinable public func updateChanges<Record>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, from record: Record) throws -> Swift.Bool where Record : GRDB.MutablePersistableRecord {
        try updateChanges(db, onConflict: conflictResolution, from: PersistenceContainer(db, record))
    }
  @discardableResult
  @inlinable public mutating func updateChanges(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, modify: (inout Self) throws -> Swift.Void) throws -> Swift.Bool {
        let container = try PersistenceContainer(db, self)
        try modify(&self)
        return try updateChanges(db, onConflict: conflictResolution, from: container)
    }
}
extension GRDB.MutablePersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func updateAndFetch(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws -> Self? where Self : GRDB.FetchableRecord {
        try updateAndFetch(db, onConflict: conflictResolution, as: Self.self)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func updateAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, as returnedType: T.Type) throws -> T? where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try updateAndFetch(db, onConflict: conflictResolution, selection: T.databaseSelection) {
            try T.fetchOne($0)
        }
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func updateChangesAndFetch(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, modify: (inout Self) throws -> Swift.Void) throws -> Self? where Self : GRDB.FetchableRecord {
        try updateChangesAndFetch(db, onConflict: conflictResolution, as: Self.self, modify: modify)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func updateChangesAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, as returnedType: T.Type, modify: (inout Self) throws -> Swift.Void) throws -> T? where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try updateChangesAndFetch(
            db, onConflict: conflictResolution,
            selection: T.databaseSelection,
            fetch: { try T.fetchOne($0) },
            modify: modify)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func updateAndFetch<T, Columns>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, columns: Columns, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T where Columns : Swift.Sequence, Columns.Element == Swift.String {
        GRDBPrecondition(!selection.isEmpty, "Invalid empty selection")
        
        try willSave(db)
        
        var success: (updated: PersistenceSuccess, returned: T)?
        try aroundSave(db) {
            success = try updateAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                columns: Set(columns),
                selection: selection,
                fetch: fetch)
            return success!.updated
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(success.updated)
        return success.returned
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func updateAndFetch<T, Columns>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, columns: Columns, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T where Columns : Swift.Sequence, Columns.Element : GRDB.ColumnExpression {
        try updateAndFetch(
            db, onConflict: conflictResolution,
            columns: columns.map(\.name),
            selection: selection,
            fetch: fetch)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func updateAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T {
        let databaseTableName = type(of: self).databaseTableName
        let columns = try db.columns(in: databaseTableName).map(\.name)
        return try updateAndFetch(
            db, onConflict: conflictResolution,
            columns: columns,
            selection: selection,
            fetch: fetch)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func updateChangesAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T?, modify: (inout Self) throws -> Swift.Void) throws -> T? {
        let container = try PersistenceContainer(db, self)
        try modify(&self)
        return try updateChangesAndFetch(
            db, onConflict: conflictResolution,
            from: container,
            selection: selection,
            fetch: fetch)
    }
}
extension GRDB.MutablePersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable internal func updateChangesAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, from container: GRDB.PersistenceContainer, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T?) throws -> T? {
        let changes = try PersistenceContainer(db, self).changesIterator(from: container)
        let changedColumns: Set<String> = changes.reduce(into: []) { $0.insert($1.0) }
        if changedColumns.isEmpty {
            return nil
        }
        return try updateAndFetch(
            db, onConflict: conflictResolution,
            columns: changedColumns,
            selection: selection,
            fetch: fetch)
    }
  @inlinable internal func updateWithCallbacks(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, columns: Swift.Set<Swift.String>) throws -> GRDB.PersistenceSuccess {
        let (updated, _) = try updateAndFetchWithCallbacks(
            db, onConflict: conflictResolution,
            columns: columns,
            selection: [],
            fetch: {
                // Nothing to fetch
                try $0.execute()
            })
        return updated
    }
  @inlinable internal func updateAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, columns: Swift.Set<Swift.String>, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.PersistenceSuccess, T) {
        try willUpdate(db, columns: columns)
        
        var success: (updated: PersistenceSuccess, returned: T)?
        try aroundUpdate(db, columns: columns) {
            success = try updateAndFetchWithoutCallbacks(
                db, onConflict: conflictResolution,
                columns: columns,
                selection: selection,
                fetch: fetch)
            return success!.updated
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundUpdate")
        }
        didUpdate(success.updated)
        return success
    }
  @usableFromInline
  internal func updateAndFetchWithoutCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, columns: Swift.Set<Swift.String>, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.PersistenceSuccess, T)
  @inlinable internal func updateChanges(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, from container: GRDB.PersistenceContainer) throws -> Swift.Bool {
        let changes = try PersistenceContainer(db, self).changesIterator(from: container)
        let changedColumns: Set<String> = changes.reduce(into: []) { $0.insert($1.0) }
        if changedColumns.isEmpty {
            return false
        }
        try update(db, onConflict: conflictResolution, columns: changedColumns)
        return true
    }
}
extension Foundation.Data : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  public init(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Foundation.Data?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.String {
  public var quotedDatabaseIdentifier: Swift.String {
    get
  }
}
public func databaseQuestionMarks(count: Swift.Int) -> Swift.String
@inline(__always) @inlinable internal func GRDBPrecondition(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = "", file: Swift.StaticString = #file, line: Swift.UInt = #line) {
    // Custom precondition function which aims at solving
    // <https://bugs.swift.org/browse/SR-905> and
    // <https://github.com/groue/GRDB.swift/issues/37>
    if !condition() {
        fatalError(message(), file: file, line: line)
    }
}
public struct DatabaseMigrator {
  public enum ForeignKeyChecks {
    case deferred
    case immediate
    public static func == (a: GRDB.DatabaseMigrator.ForeignKeyChecks, b: GRDB.DatabaseMigrator.ForeignKeyChecks) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var eraseDatabaseOnSchemaChange: Swift.Bool
  public init()
  public func disablingDeferredForeignKeyChecks() -> GRDB.DatabaseMigrator
  public mutating func registerMigration(_ identifier: Swift.String, foreignKeyChecks: GRDB.DatabaseMigrator.ForeignKeyChecks = .deferred, migrate: @escaping (GRDB.Database) throws -> Swift.Void)
  public func migrate(_ writer: some DatabaseWriter) throws
  public func migrate(_ writer: some DatabaseWriter, upTo targetIdentifier: Swift.String) throws
  public func asyncMigrate(_ writer: some DatabaseWriter, completion: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  public var migrations: [Swift.String] {
    get
  }
  public func appliedMigrations(_ db: GRDB.Database) throws -> [Swift.String]
  public func appliedIdentifiers(_ db: GRDB.Database) throws -> Swift.Set<Swift.String>
  public func completedMigrations(_ db: GRDB.Database) throws -> [Swift.String]
  public func hasCompletedMigrations(_ db: GRDB.Database) throws -> Swift.Bool
  public func hasBeenSuperseded(_ db: GRDB.Database) throws -> Swift.Bool
}
extension GRDB.DatabaseMigrator {
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func migratePublisher(_ writer: some DatabaseWriter, receiveOn scheduler: some Scheduler = DispatchQueue.main) -> GRDB.DatabasePublishers.Migrate
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.DatabasePublishers {
  public struct Migrate : Combine.Publisher {
    public typealias Output = Swift.Void
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == ()
  }
}
@_hasMissingDesignatedInitializers final public class ColumnDefinition {
  public enum GeneratedColumnQualification {
    case virtual
    case stored
    public static func == (a: GRDB.ColumnDefinition.GeneratedColumnQualification, b: GRDB.ColumnDefinition.GeneratedColumnQualification) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @discardableResult
  final public func primaryKey(onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, autoincrement: Swift.Bool = false) -> Self
  @discardableResult
  final public func notNull(onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func unique(onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func indexed() -> Self
  @discardableResult
  final public func check(_ condition: (GRDB.Column) -> any GRDB.SQLExpressible) -> Self
  @discardableResult
  final public func check(sql: Swift.String) -> Self
  @discardableResult
  final public func defaults(to value: some DatabaseValueConvertible) -> Self
  @discardableResult
  final public func defaults(sql: Swift.String) -> Self
  @discardableResult
  final public func collate(_ collation: GRDB.Database.CollationName) -> Self
  @discardableResult
  final public func collate(_ collation: GRDB.DatabaseCollation) -> Self
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @discardableResult
  final public func generatedAs(sql: Swift.String, _ qualification: GRDB.ColumnDefinition.GeneratedColumnQualification = .virtual) -> Self
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @discardableResult
  final public func generatedAs(_ expression: some SQLExpressible, _ qualification: GRDB.ColumnDefinition.GeneratedColumnQualification = .virtual) -> Self
  @discardableResult
  final public func references(_ table: Swift.String, column: Swift.String? = nil, onDelete deleteAction: GRDB.Database.ForeignKeyAction? = nil, onUpdate updateAction: GRDB.Database.ForeignKeyAction? = nil, deferred isDeferred: Swift.Bool = false) -> Self
  @objc deinit
}
public struct JoinAssociation<Origin, Destination> {
  public var _sqlAssociation: GRDB._SQLAssociation
}
extension GRDB.JoinAssociation : GRDB.AssociationToOne {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
}
public enum SharedValueObservationExtent {
  case observationLifetime
  case whileObserved
  public static func == (a: GRDB.SharedValueObservationExtent, b: GRDB.SharedValueObservationExtent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension GRDB.ValueObservation {
  public func shared(in reader: some DatabaseReader, scheduling scheduler: some ValueObservationScheduler = .async(onQueue: .main), extent: GRDB.SharedValueObservationExtent = .whileObserved) -> GRDB.SharedValueObservation<Reducer.Value> where Reducer : GRDB.ValueReducer
}
@_hasMissingDesignatedInitializers final public class SharedValueObservation<Element> {
  final public func start(onError: @escaping (any Swift.Error) -> Swift.Void, onChange: @escaping (Element) -> Swift.Void) -> GRDB.AnyDatabaseCancellable
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  final public func publisher() -> GRDB.DatabasePublishers.Value<Element>
  @objc deinit
}
extension GRDB.SharedValueObservation {
  #if compiler(>=5.3) && $RethrowsProtocol
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  final public func values(bufferingPolicy: GRDB.AsyncValueObservation<Element>.BufferingPolicy = .unbounded) -> GRDB.AsyncValueObservation<Element>
  #endif
}
public struct SQLInterpolation : Swift.StringInterpolationProtocol {
  public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
  public mutating func appendLiteral(_ sql: Swift.String)
  public mutating func appendInterpolation(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments())
  public mutating func appendInterpolation(_ sqlLiteral: GRDB.SQL)
  public mutating func appendInterpolation<S>(_ string: S) where S : Swift.StringProtocol
  public mutating func appendInterpolation(literal sqlLiteral: GRDB.SQL)
  public typealias StringLiteralType = Swift.String
}
public struct DatabaseDateComponents {
  public enum Format : Swift.String {
    case YMD
    case YMD_HM
    case YMD_HMS
    case YMD_HMSS
    case HM
    case HMS
    case HMSS
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let dateComponents: Foundation.DateComponents
  public let format: GRDB.DatabaseDateComponents.Format
  public init(_ dateComponents: Foundation.DateComponents, format: GRDB.DatabaseDateComponents.Format)
}
extension GRDB.DatabaseDateComponents : GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        guard let cString = sqlite3_column_text(sqliteStatement, index) else {
            return nil
        }
        let length = Int(sqlite3_column_bytes(sqliteStatement, index)) // avoid an strlen
        let components = cString.withMemoryRebound(
            to: Int8.self,
            capacity: length + 1 /* trailing \0 */) { cString in
            SQLiteDateParser().components(cString: cString, length: length)
        }
        guard let components else {
            return nil
        }
        self.init(components.dateComponents, format: components.format)
    }
}
extension GRDB.DatabaseDateComponents : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> GRDB.DatabaseDateComponents?
}
extension GRDB.DatabaseDateComponents : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension GRDB.DatabaseDateComponents : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Foundation.Decimal : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Foundation.Decimal?
}
extension Foundation.Decimal : GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        switch sqlite3_column_type(sqliteStatement, index) {
        case SQLITE_INTEGER:
            self.init(sqlite3_column_int64(sqliteStatement, index))
        case SQLITE_FLOAT:
            self.init(sqlite3_column_double(sqliteStatement, index))
        case SQLITE_TEXT:
            self.init(
                string: String(cString: sqlite3_column_text(sqliteStatement, index)!),
                locale: _posixLocale)
        default:
            return nil
        }
    }
}
@usableFromInline
internal let _posixLocale: Foundation.Locale
@_hasMissingDesignatedInitializers final public class TableAlteration {
  @discardableResult
  final public func add(column name: Swift.String, _ type: GRDB.Database.ColumnType? = nil) -> GRDB.ColumnDefinition
  final public func addColumn(sql: Swift.String)
  final public func addColumn(literal: GRDB.SQL)
  @available(iOS 13, tvOS 13, watchOS 6, *)
  final public func rename(column name: Swift.String, to newName: Swift.String)
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  final public func drop(column name: Swift.String)
  @objc deinit
}
public struct FTS5Pattern {
  public let rawPattern: Swift.String
  public init?(matchingAnyTokenIn string: Swift.String)
  public init?(matchingAllTokensIn string: Swift.String)
  public init?(matchingAllPrefixesIn string: Swift.String)
  public init?(matchingPhrase string: Swift.String)
  public init?(matchingPrefixPhrase string: Swift.String)
}
extension GRDB.Database {
  final public func makeFTS5Pattern(rawPattern: Swift.String, forTable table: Swift.String) throws -> GRDB.FTS5Pattern
}
extension GRDB.FTS5Pattern : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> GRDB.FTS5Pattern?
}
public struct SQLRequest<RowDecoder> {
  public var adapter: (any GRDB.RowAdapter)?
}
extension GRDB.SQLRequest {
  public init(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil, cached: Swift.Bool = false)
  public init(literal sqlLiteral: GRDB.SQL, adapter: (any GRDB.RowAdapter)? = nil, cached: Swift.Bool = false)
}
extension GRDB.SQLRequest where RowDecoder == GRDB.Row {
  public init(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil, cached: Swift.Bool = false)
  public init(literal sqlLiteral: GRDB.SQL, adapter: (any GRDB.RowAdapter)? = nil, cached: Swift.Bool = false)
}
extension GRDB.SQLRequest : GRDB.FetchRequest {
  public var sqlSubquery: GRDB.SQLSubquery {
    get
  }
  public func fetchCount(_ db: GRDB.Database) throws -> Swift.Int
  public func makePreparedRequest(_ db: GRDB.Database, forSingleResult singleResult: Swift.Bool = false) throws -> GRDB.PreparedRequest
}
extension GRDB.SQLRequest : Swift.ExpressibleByStringInterpolation {
  public init(unicodeScalarLiteral: Swift.String)
  public init(extendedGraphemeClusterLiteral: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(stringInterpolation sqlInterpolation: GRDB.SQLInterpolation)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringInterpolation = GRDB.SQLInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public protocol DatabaseReader : AnyObject, Swift.Sendable {
  var configuration: GRDB.Configuration { get }
  func close() throws
  func interrupt()
  @_disfavoredOverload func read<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  @_disfavoredOverload func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
extension GRDB.DatabaseReader {
  public func backup(to writer: some DatabaseWriter, pagesPerStep: Swift.CInt = -1, progress: ((GRDB.DatabaseBackupProgress) throws -> Swift.Void)? = nil) throws
}
extension GRDB.DatabaseReader {
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func read<T>(_ value: @escaping @Sendable (GRDB.Database) throws -> T) async throws -> T
  #endif
  #if compiler(>=5.3) && $AsyncAwait && $Sendable
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func unsafeRead<T>(_ value: @escaping @Sendable (GRDB.Database) throws -> T) async throws -> T
  #endif
}
extension GRDB.DatabaseReader {
  @available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
  public func readPublisher<Output>(receiveOn scheduler: some Combine.Scheduler = DispatchQueue.main, value: @escaping (GRDB.Database) throws -> Output) -> GRDB.DatabasePublishers.Read<Output>
}
@available(iOS 13, macOS 10.15, tvOS 13, watchOS 6, *)
extension GRDB.DatabasePublishers {
  public struct Read<Output> : Combine.Publisher {
    public typealias Output = Output
    public typealias Failure = Swift.Error
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, S.Failure == any Swift.Error
  }
}
final public class AnyDatabaseReader {
  public init(_ base: some DatabaseReader)
  @objc deinit
}
extension GRDB.AnyDatabaseReader : GRDB.DatabaseReader {
  final public var configuration: GRDB.Configuration {
    get
  }
  final public func close() throws
  final public func interrupt()
  @_disfavoredOverload final public func read<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  @_disfavoredOverload final public func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
public protocol DatabaseSnapshotReader : GRDB.DatabaseReader {
}
extension GRDB.DatabaseSnapshotReader {
  public func reentrantRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  public func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  public func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
}
extension Foundation.NSNull : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
extension GRDB.TableRequest where Self : GRDB.FilteredRequest {
  public func matching(_ pattern: GRDB.FTS5Pattern?) -> Self
}
extension GRDB.TableRecord {
  public static func matching(_ pattern: GRDB.FTS5Pattern?) -> GRDB.QueryInterfaceRequest<Self>
}
extension GRDB.ColumnExpression {
  public func match(_ pattern: GRDB.FTS5Pattern) -> GRDB.SQLExpression
}
public struct SQLSubquery {
}
public protocol SQLSubqueryable : GRDB.SQLSpecificExpressible {
  var sqlSubquery: GRDB.SQLSubquery { get }
}
extension GRDB.SQLSubquery : GRDB.SQLSubqueryable {
  @available(*, deprecated, message: "Already SQLSubquery")
  public var sqlSubquery: GRDB.SQLSubquery {
    get
  }
}
extension GRDB.SQLSubqueryable {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
extension GRDB.SQLSubqueryable {
  public func contains(_ element: some SQLExpressible) -> GRDB.SQLExpression
  public func exists() -> GRDB.SQLExpression
}
extension GRDB.FetchableRecord where Self : Swift.Decodable {
  public init(row: GRDB.Row) throws
}
public class FetchableRecordDecoder {
  public init()
  public func decode<T>(_ type: T.Type, from row: GRDB.Row) throws -> T where T : GRDB.FetchableRecord, T : Swift.Decodable
  @objc deinit
}
extension GRDB.SQLInterpolation {
  public mutating func appendInterpolation(_ table: (some TableRecord).Type)
  @_disfavoredOverload public mutating func appendInterpolation(_ table: any GRDB.TableRecord.Type)
  @_disfavoredOverload public mutating func appendInterpolation<T>(_ table: GRDB.Table<T>)
  public mutating func appendInterpolation(tableOf record: some TableRecord)
  public mutating func appendInterpolation(identifier: Swift.String)
  @_disfavoredOverload public mutating func appendInterpolation(tableOf record: any GRDB.TableRecord)
  public mutating func appendInterpolation(columnsOf recordType: (some TableRecord).Type, tableAlias: Swift.String? = nil)
  public mutating func appendInterpolation(_ selection: some SQLSelectable)
  @_disfavoredOverload public mutating func appendInterpolation(_ selection: (any GRDB.SQLSelectable)?)
  public mutating func appendInterpolation(_ orderingTerm: some SQLOrderingTerm)
  @_disfavoredOverload public mutating func appendInterpolation(_ orderingTerm: any GRDB.SQLOrderingTerm)
  public mutating func appendInterpolation(_ expressible: some SQLExpressible & SQLSelectable & SQLOrderingTerm)
  @_disfavoredOverload public mutating func appendInterpolation(_ expressible: (any GRDB.SQLExpressible)?)
  public mutating func appendInterpolation(_ key: some CodingKey)
  public mutating func appendInterpolation(_ key: some CodingKey & SQLExpressible & SQLSelectable & SQLOrderingTerm)
  @_disfavoredOverload public mutating func appendInterpolation(_ key: any Swift.CodingKey)
  public mutating func appendInterpolation(_ subquery: some SQLSubqueryable & SQLExpressible & SQLSelectable & SQLOrderingTerm)
  public mutating func appendInterpolation<S>(_ sequence: S) where S : Swift.Sequence, S.Element : GRDB.SQLExpressible
  public mutating func appendInterpolation<S>(_ sequence: S) where S : Swift.Sequence, S.Element == any GRDB.SQLExpressible
  public mutating func appendInterpolation<S>(_ expressible: S) where S : GRDB.SQLExpressible, S : Swift.Sequence, S.Element : GRDB.SQLExpressible
  public mutating func appendInterpolation(_ cte: GRDB.CommonTableExpression<some Any>)
  public mutating func appendInterpolation(definitionFor cte: GRDB.CommonTableExpression<some Any>)
  public mutating func appendInterpolation(_ collation: GRDB.DatabaseCollation)
  public mutating func appendInterpolation(_ collation: GRDB.Database.CollationName)
}
extension GRDB.ValueReducers {
  public struct Trace<Base> : GRDB._ValueReducer where Base : GRDB._ValueReducer {
    public mutating func _value(_ fetched: Base.Fetched) throws -> Base.Value?
    public typealias Fetched = Base.Fetched
    public typealias Value = Base.Value
  }
}
extension GRDB.ValueReducers.Trace : GRDB.ValueReducer where Base : GRDB.ValueReducer {
  public func _fetch(_ db: GRDB.Database) throws -> Base.Fetched
}
public protocol VirtualTableModule {
  associatedtype TableDefinition
  var moduleName: Swift.String { get }
  func makeTableDefinition(configuration: GRDB.VirtualTableConfiguration) -> Self.TableDefinition
  func moduleArguments(for definition: Self.TableDefinition, in db: GRDB.Database) throws -> [Swift.String]
  func database(_ db: GRDB.Database, didCreate tableName: Swift.String, using definition: Self.TableDefinition) throws
}
public struct VirtualTableConfiguration {
}
extension GRDB.Database {
  final public func create(virtualTable name: Swift.String, ifNotExists: Swift.Bool = false, using module: Swift.String) throws
  final public func create<Module>(virtualTable tableName: Swift.String, ifNotExists: Swift.Bool = false, using module: Module, _ body: ((Module.TableDefinition) throws -> Swift.Void)? = nil) throws where Module : GRDB.VirtualTableModule
}
public typealias SQLiteConnection = Swift.OpaquePointer
@_hasMissingDesignatedInitializers final public class Database : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public var sqliteConnection: GRDB.SQLiteConnection? {
    get
  }
  public static var logError: GRDB.Database.LogErrorFunction? {
    get
    set
  }
  final public let configuration: GRDB.Configuration
  final public let description: Swift.String
  final public var debugDescription: Swift.String {
    get
  }
  final public var lastInsertedRowID: Swift.Int64 {
    get
  }
  final public var changesCount: Swift.Int {
    get
  }
  final public var totalChangesCount: Swift.Int {
    get
  }
  final public var isInsideTransaction: Swift.Bool {
    get
  }
  final public var lastErrorCode: GRDB.ResultCode {
    get
  }
  final public var lastErrorMessage: Swift.String? {
    get
  }
  #if compiler(>=5.3) && $EffectfulProp
  final public var transactionDate: Foundation.Date {
    get throws
  }
  #endif
  @objc deinit
  final public var maximumStatementArgumentCount: Swift.Int {
    get
  }
  final public func add(function: GRDB.DatabaseFunction)
  final public func remove(function: GRDB.DatabaseFunction)
  final public func add(collation: GRDB.DatabaseCollation)
  final public func remove(collation: GRDB.DatabaseCollation)
  final public func registerAccess(to region: @autoclosure () -> some DatabaseRegionConvertible) throws
  final public func trace(options: GRDB.Database.TracingOptions = .statement, _ trace: ((GRDB.Database.TraceEvent) -> Swift.Void)? = nil)
  @discardableResult
  final public func checkpoint(_ kind: GRDB.Database.CheckpointMode = .passive, on dbName: Swift.String? = "main") throws -> (walFrameCount: Swift.Int, checkpointedFrameCount: Swift.Int)
  public static let suspendNotification: Foundation.Notification.Name
  public static let resumeNotification: Foundation.Notification.Name
  final public func inTransaction(_ kind: GRDB.Database.TransactionKind? = nil, _ operations: () throws -> GRDB.Database.TransactionCompletion) throws
  final public func inSavepoint(_ operations: () throws -> GRDB.Database.TransactionCompletion) throws
  final public func beginTransaction(_ kind: GRDB.Database.TransactionKind? = nil) throws
  final public func rollback() throws
  final public func commit() throws
  final public func releaseMemory()
  final public func backup(to destDb: GRDB.Database, pagesPerStep: Swift.CInt = -1, progress: ((GRDB.DatabaseBackupProgress) throws -> Swift.Void)? = nil) throws
}
extension GRDB.Database {
  public typealias BusyCallback = (_ numberOfTries: Swift.Int) -> Swift.Bool
  public enum BusyMode {
    case immediateError
    case timeout(Foundation.TimeInterval)
    case callback(GRDB.Database.BusyCallback)
  }
  public enum CheckpointMode : Swift.CInt {
    case passive
    case full
    case restart
    case truncate
    public init?(rawValue: Swift.CInt)
    public typealias RawValue = Swift.CInt
    public var rawValue: Swift.CInt {
      get
    }
  }
  public struct CollationName : Swift.RawRepresentable, Swift.Hashable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public static let binary: GRDB.Database.CollationName
    public static let nocase: GRDB.Database.CollationName
    public static let rtrim: GRDB.Database.CollationName
    public typealias RawValue = Swift.String
  }
  public struct ColumnType : Swift.RawRepresentable, Swift.Hashable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public static let text: GRDB.Database.ColumnType
    public static let integer: GRDB.Database.ColumnType
    public static let double: GRDB.Database.ColumnType
    public static let real: GRDB.Database.ColumnType
    public static let numeric: GRDB.Database.ColumnType
    public static let boolean: GRDB.Database.ColumnType
    public static let blob: GRDB.Database.ColumnType
    public static let date: GRDB.Database.ColumnType
    public static let datetime: GRDB.Database.ColumnType
    public static let any: GRDB.Database.ColumnType
    public typealias RawValue = Swift.String
  }
  public enum ConflictResolution : Swift.String {
    case rollback
    case abort
    case fail
    case ignore
    case replace
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ForeignKeyAction : Swift.String {
    case cascade
    case restrict
    case setNull
    case setDefault
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias LogErrorFunction = (_ resultCode: GRDB.ResultCode, _ message: Swift.String) -> Swift.Void
  public struct TracingOptions : Swift.OptionSet {
    public let rawValue: Swift.CInt
    public init(rawValue: Swift.CInt)
    public static let statement: GRDB.Database.TracingOptions
    public static let profile: GRDB.Database.TracingOptions
    public typealias ArrayLiteralElement = GRDB.Database.TracingOptions
    public typealias Element = GRDB.Database.TracingOptions
    public typealias RawValue = Swift.CInt
  }
  public enum TraceEvent : Swift.CustomStringConvertible {
    public struct Statement : Swift.CustomStringConvertible {
      public var sql: Swift.String {
        get
      }
      public var expandedSQL: Swift.String {
        get
      }
      public var description: Swift.String {
        get
      }
    }
    case statement(GRDB.Database.TraceEvent.Statement)
    case profile(statement: GRDB.Database.TraceEvent.Statement, duration: Foundation.TimeInterval)
    public var description: Swift.String {
      get
    }
    public var expandedDescription: Swift.String {
      get
    }
  }
  @frozen public enum TransactionCompletion {
    case commit
    case rollback
    public static func == (a: GRDB.Database.TransactionCompletion, b: GRDB.Database.TransactionCompletion) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum TransactionKind : Swift.String {
    case deferred
    case immediate
    case exclusive
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public struct TableOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let ifNotExists: GRDB.TableOptions
  public static let temporary: GRDB.TableOptions
  public static let withoutRowID: GRDB.TableOptions
  @available(iOS 15.4, macOS 12.4, tvOS 15.4, watchOS 8.5, *)
  public static let strict: GRDB.TableOptions
  public typealias ArrayLiteralElement = GRDB.TableOptions
  public typealias Element = GRDB.TableOptions
  public typealias RawValue = Swift.Int
}
@_hasMissingDesignatedInitializers final public class TableDefinition {
  @discardableResult
  final public func autoIncrementedPrimaryKey(_ name: Swift.String, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) -> GRDB.ColumnDefinition
  @discardableResult
  final public func primaryKey(_ name: Swift.String, _ type: GRDB.Database.ColumnType, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) -> GRDB.ColumnDefinition
  final public func primaryKey(onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, body: () throws -> Swift.Void) rethrows
  @discardableResult
  final public func column(_ name: Swift.String, _ type: GRDB.Database.ColumnType? = nil) -> GRDB.ColumnDefinition
  final public func column(sql: Swift.String)
  final public func column(literal: GRDB.SQL)
  final public func primaryKey(_ columns: [Swift.String], onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil)
  final public func uniqueKey(_ columns: [Swift.String], onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil)
  final public func foreignKey(_ columns: [Swift.String], references table: Swift.String, columns destinationColumns: [Swift.String]? = nil, onDelete deleteAction: GRDB.Database.ForeignKeyAction? = nil, onUpdate updateAction: GRDB.Database.ForeignKeyAction? = nil, deferred isDeferred: Swift.Bool = false)
  @discardableResult
  final public func belongsTo(_ name: Swift.String, inTable table: Swift.String? = nil, onDelete deleteAction: GRDB.Database.ForeignKeyAction? = nil, onUpdate updateAction: GRDB.Database.ForeignKeyAction? = nil, deferred isDeferred: Swift.Bool = false, indexed: Swift.Bool = true) -> GRDB.ForeignKeyDefinition
  @available(*, deprecated)
  final public func check(_ condition: some SQLExpressible)
  final public func check(_ condition: some SQLSpecificExpressible)
  final public func check(sql: Swift.String)
  final public func constraint(sql: Swift.String)
  final public func constraint(literal: GRDB.SQL)
  @objc deinit
}
extension GRDB.MutablePersistableRecord {
  @inline(__always) @inlinable public mutating func willInsert(_ db: GRDB.Database) throws { }
  @inline(__always) @inlinable public func aroundInsert(_ db: GRDB.Database, insert: () throws -> GRDB.InsertionSuccess) throws {
        _ = try insert()
    }
  @inline(__always) @inlinable public mutating func didInsert(_ inserted: GRDB.InsertionSuccess) { }
}
extension GRDB.MutablePersistableRecord {
  @inlinable public mutating func insert(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws {
        try willSave(db)
        
        var saved: PersistenceSuccess?
        try aroundSave(db) {
            let inserted = try insertWithCallbacks(db, onConflict: conflictResolution)
            saved = PersistenceSuccess(inserted)
            return saved!
        }
        
        guard let saved else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(saved)
    }
  @inlinable public func inserted(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws -> Self {
        var result = self
        try result.insert(db, onConflict: conflictResolution)
        return result
    }
}
extension GRDB.MutablePersistableRecord {
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public func insertAndFetch(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil) throws -> Self? where Self : GRDB.FetchableRecord {
        var result = self
        return try result.insertAndFetch(db, onConflict: conflictResolution, as: Self.self)
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func insertAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, as returnedType: T.Type) throws -> T? where T : GRDB.FetchableRecord, T : GRDB.TableRecord {
        try insertAndFetch(db, onConflict: conflictResolution, selection: T.databaseSelection) {
            try T.fetchOne($0)
        }
    }
  @available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
  @inlinable public mutating func insertAndFetch<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> T {
        GRDBPrecondition(!selection.isEmpty, "Invalid empty selection")
        
        try willSave(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundSave(db) {
            success = try insertAndFetchWithCallbacks(
                db, onConflict: conflictResolution,
                selection: selection,
                fetch: fetch)
            return PersistenceSuccess(success!.inserted)
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundSave")
        }
        didSave(PersistenceSuccess(success.inserted))
        return success.returned
    }
}
extension GRDB.MutablePersistableRecord {
  @inlinable internal mutating func insertWithCallbacks(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?) throws -> GRDB.InsertionSuccess {
        let (inserted, _) = try insertAndFetchWithCallbacks(db, onConflict: conflictResolution, selection: []) {
            // Nothing to fetch
            try $0.execute()
        }
        return inserted
    }
  @inlinable internal mutating func insertAndFetchWithCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.InsertionSuccess, T) {
        try willInsert(db)
        
        var success: (inserted: InsertionSuccess, returned: T)?
        try aroundInsert(db) {
            success = try insertAndFetchWithoutCallbacks(
                db, onConflict: conflictResolution,
                selection: selection,
                fetch: fetch)
            return success!.inserted
        }
        
        guard let success else {
            try persistenceCallbackMisuse("aroundInsert")
        }
        didInsert(success.inserted)
        return success
    }
  @usableFromInline
  internal func insertAndFetchWithoutCallbacks<T>(_ db: GRDB.Database, onConflict conflictResolution: GRDB.Database.ConflictResolution?, selection: [any GRDB.SQLSelectable], fetch: (GRDB.Statement) throws -> T) throws -> (GRDB.InsertionSuccess, T)
}
@usableFromInline
internal enum RowKey : Swift.Hashable, Swift.Sendable {
  case columnName(Swift.String)
  case columnIndex(Swift.Int)
  case scope(Swift.String)
  case prefetchKey(Swift.String)
  @usableFromInline
  internal func hash(into hasher: inout Swift.Hasher)
  @usableFromInline
  internal static func == (a: GRDB.RowKey, b: GRDB.RowKey) -> Swift.Bool
  @usableFromInline
  internal var hashValue: Swift.Int {
    @usableFromInline
    get
  }
}
@usableFromInline
internal enum RowDecodingError : Swift.Error {
  @usableFromInline
  internal struct Context : Swift.CustomDebugStringConvertible, Swift.Sendable {
    @usableFromInline
    internal let debugDescription: Swift.String
  }
  case keyNotFound(GRDB.RowKey, GRDB.RowDecodingError.Context)
  case valueMismatch(any Any.Type, GRDB.RowDecodingError.Context)
  @usableFromInline
  internal static func valueMismatch(_ type: any Any.Type, sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt, context: GRDB.RowDecodingContext) -> GRDB.RowDecodingError
  @usableFromInline
  internal static func columnNotFound(_ columnName: Swift.String, context: GRDB.RowDecodingContext) -> GRDB.RowDecodingError
}
@usableFromInline
internal struct RowDecodingContext {
  @usableFromInline
  internal init(row: GRDB.Row, key: GRDB.RowKey? = nil)
  @usableFromInline
  internal init(statement: GRDB.Statement, index: Swift.Int)
}
extension GRDB.RowDecodingError : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
public struct FTS5TokenFlags : Swift.OptionSet {
  public let rawValue: Swift.CInt
  public init(rawValue: Swift.CInt)
  public static let colocated: GRDB.FTS5TokenFlags
  public typealias ArrayLiteralElement = GRDB.FTS5TokenFlags
  public typealias Element = GRDB.FTS5TokenFlags
  public typealias RawValue = Swift.CInt
}
public typealias FTS5WrapperTokenCallback = (_ token: Swift.String, _ flags: GRDB.FTS5TokenFlags) throws -> Swift.Void
public protocol FTS5WrapperTokenizer : GRDB.FTS5CustomTokenizer {
  var wrappedTokenizer: any GRDB.FTS5Tokenizer { get }
  func accept(token: Swift.String, flags: GRDB.FTS5TokenFlags, for tokenization: GRDB.FTS5Tokenization, tokenCallback: (_ token: Swift.String, _ flags: GRDB.FTS5TokenFlags) throws -> Swift.Void) throws
}
extension GRDB.FTS5WrapperTokenizer {
  public func tokenize(context: Swift.UnsafeMutableRawPointer?, tokenization: GRDB.FTS5Tokenization, pText: Swift.UnsafePointer<Swift.Int8>?, nText: Swift.CInt, tokenCallback: GRDB.FTS5TokenCallback) -> Swift.CInt
}
final public class DatabaseQueue {
  final public var configuration: GRDB.Configuration {
    get
  }
  final public var path: Swift.String {
    get
  }
  public init(path: Swift.String, configuration: GRDB.Configuration = Configuration()) throws
  public init(named name: Swift.String? = nil, configuration: GRDB.Configuration = Configuration()) throws
  @objc deinit
}
extension GRDB.DatabaseQueue : @unchecked Swift.Sendable {
}
extension GRDB.DatabaseQueue {
  final public func releaseMemory()
}
extension GRDB.DatabaseQueue : GRDB.DatabaseReader {
  final public func close() throws
  final public func interrupt()
  @_disfavoredOverload final public func read<T>(_ value: (GRDB.Database) throws -> T) throws -> T
  final public func asyncRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeRead<T>(_ value: (GRDB.Database) throws -> T) rethrows -> T
  final public func asyncUnsafeRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func unsafeReentrantRead<T>(_ value: (GRDB.Database) throws -> T) rethrows -> T
  final public func concurrentRead<T>(_ value: @escaping (GRDB.Database) throws -> T) -> GRDB.DatabaseFuture<T>
  final public func spawnConcurrentRead(_ value: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func _add<Reducer>(observation: GRDB.ValueObservation<Reducer>, scheduling scheduler: some ValueObservationScheduler, onChange: @escaping (Reducer.Value) -> Swift.Void) -> GRDB.AnyDatabaseCancellable where Reducer : GRDB.ValueReducer
}
extension GRDB.DatabaseQueue : GRDB.DatabaseWriter {
  final public func inTransaction(_ kind: GRDB.Database.TransactionKind? = nil, _ updates: (GRDB.Database) throws -> GRDB.Database.TransactionCompletion) throws
  @_disfavoredOverload final public func writeWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  @_disfavoredOverload final public func barrierWriteWithoutTransaction<T>(_ updates: (GRDB.Database) throws -> T) throws -> T
  final public func asyncBarrierWriteWithoutTransaction(_ updates: @escaping (Swift.Result<GRDB.Database, any Swift.Error>) -> Swift.Void)
  final public func inDatabase<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  final public func unsafeReentrantWrite<T>(_ updates: (GRDB.Database) throws -> T) rethrows -> T
  final public func asyncWriteWithoutTransaction(_ updates: @escaping (GRDB.Database) -> Swift.Void)
}
extension Foundation.NSNumber : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
public struct SQL {
  public init(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments())
  public init(_ expression: some SQLSpecificExpressible)
  public var isEmpty: Swift.Bool {
    get
  }
  public func build(_ db: GRDB.Database) throws -> (sql: Swift.String, arguments: GRDB.StatementArguments)
}
extension GRDB.SQL {
  public static func + (lhs: GRDB.SQL, rhs: GRDB.SQL) -> GRDB.SQL
  public static func += (lhs: inout GRDB.SQL, rhs: GRDB.SQL)
  public mutating func append(literal sqlLiteral: GRDB.SQL)
  public mutating func append(sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments())
}
extension GRDB.SQL : GRDB.SQLSpecificExpressible {
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
extension GRDB.SQL : GRDB.SQLSelectable {
  public var sqlSelection: GRDB.SQLSelection {
    get
  }
}
extension GRDB.SQL : GRDB.SQLOrderingTerm {
  public var sqlOrdering: GRDB.SQLOrdering {
    get
  }
}
extension Swift.Sequence where Self.Element == GRDB.SQL {
  public func joined(separator: Swift.String = "") -> GRDB.SQL
}
extension Swift.Collection where Self.Element == GRDB.SQL {
  public func joined(separator: Swift.String = "") -> GRDB.SQL
}
extension GRDB.SQL : Swift.ExpressibleByStringInterpolation {
  public init(unicodeScalarLiteral: Swift.String)
  public init(extendedGraphemeClusterLiteral: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(stringInterpolation sqlInterpolation: GRDB.SQLInterpolation)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringInterpolation = GRDB.SQLInterpolation
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@usableFromInline
internal struct SQLiteDateParser {
  @usableFromInline
  internal init()
  @usableFromInline
  internal func components(cString: Swift.UnsafePointer<Swift.CChar>, length: Swift.Int) -> GRDB.DatabaseDateComponents?
}
@_hasMissingDesignatedInitializers final public class Row {
  @usableFromInline
  final internal let sqliteStatement: GRDB.SQLiteStatement?
  final public let count: Swift.Int
  final public var prefetchedRows: GRDB.Row.PrefetchedRowsView {
    get
  }
  convenience public init()
  convenience public init(_ dictionary: [Swift.String : (any GRDB.DatabaseValueConvertible)?])
  convenience public init?(_ dictionary: [Swift.AnyHashable : Any])
  final public func copy() -> GRDB.Row
  @objc deinit
}
extension GRDB.Row {
  final public var columnNames: Swift.LazyMapCollection<GRDB.Row, Swift.String> {
    get
  }
  final public func hasColumn(_ columnName: Swift.String) -> Swift.Bool
  @usableFromInline
  final internal func index(forColumn name: Swift.String) -> Swift.Int?
}
extension GRDB.Row {
  @usableFromInline
  @inline(__always) final internal func _checkIndex(_ index: Swift.Int, file: Swift.StaticString = #file, line: Swift.UInt = #line)
  final public var containsNonNullValue: Swift.Bool {
    get
  }
  final public func hasNull(atIndex index: Swift.Int) -> Swift.Bool
  final public subscript(index: Swift.Int) -> (any GRDB.DatabaseValueConvertible)? {
    get
  }
  @inlinable final public subscript<Value>(index: Swift.Int) -> Value where Value : GRDB.DatabaseValueConvertible {
    get {
        try! decode(Value.self, atIndex: index)
    }
  }
  @inline(__always) @inlinable final public subscript<Value>(index: Swift.Int) -> Value where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible {
    get {
        try! decode(Value.self, atIndex: index)
    }
  }
  final public subscript(columnName: Swift.String) -> (any GRDB.DatabaseValueConvertible)? {
    get
  }
  @inlinable final public subscript<Value>(columnName: Swift.String) -> Value where Value : GRDB.DatabaseValueConvertible {
    get {
        try! decode(Value.self, forKey: columnName)
    }
  }
  @inlinable final public subscript<Value>(columnName: Swift.String) -> Value where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible {
    get {
        try! decode(Value.self, forKey: columnName)
    }
  }
  final public subscript(column: some ColumnExpression) -> (any GRDB.DatabaseValueConvertible)? {
    get
  }
  @inlinable final public subscript<Value>(column: some ColumnExpression) -> Value where Value : GRDB.DatabaseValueConvertible {
    get {
        try! decode(Value.self, forKey: column.name)
    }
  }
  @inlinable final public subscript<Value>(column: some ColumnExpression) -> Value where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible {
    get {
        try! decode(Value.self, forKey: column.name)
    }
  }
  final public func withUnsafeData<T>(atIndex index: Swift.Int, _ body: (Foundation.Data?) throws -> T) throws -> T
  final public func withUnsafeData<T>(named columnName: Swift.String, _ body: (Foundation.Data?) throws -> T) throws -> T
  final public func withUnsafeData<T>(at column: some ColumnExpression, _ body: (Foundation.Data?) throws -> T) throws -> T
  @available(*, deprecated, message: "Use withUnsafeData(atIndex:_:) instead.")
  final public func dataNoCopy(atIndex index: Swift.Int) -> Foundation.Data?
  @available(*, deprecated, message: "Use withUnsafeData(named:_:) instead.")
  final public func dataNoCopy(named columnName: Swift.String) -> Foundation.Data?
  @available(*, deprecated, message: "Use withUnsafeData(at:_:) instead.")
  final public func dataNoCopy(_ column: some ColumnExpression) -> Foundation.Data?
}
extension GRDB.Row {
  final public var databaseValues: Swift.LazyMapCollection<GRDB.Row, GRDB.DatabaseValue> {
    get
  }
}
extension GRDB.Row {
  final public subscript<Record>(scope: Swift.String) -> Record where Record : GRDB.FetchableRecord {
    get
  }
  final public subscript<Record>(scope: Swift.String) -> Record? where Record : GRDB.FetchableRecord {
    get
  }
  final public subscript<Records>(key: Swift.String) -> Records where Records : Swift.RangeReplaceableCollection, Records.Element : GRDB.FetchableRecord {
    get
  }
  final public subscript<Record>(key: Swift.String) -> Swift.Set<Record> where Record : GRDB.FetchableRecord, Record : Swift.Hashable {
    get
  }
}
extension GRDB.Row {
  final public var scopes: GRDB.Row.ScopesView {
    get
  }
  final public var scopesTree: GRDB.Row.ScopesTreeView {
    get
  }
  final public var unscoped: GRDB.Row {
    get
  }
  final public var unadapted: GRDB.Row {
    get
  }
}
extension GRDB.Row {
  @inlinable final internal func decode<Value>(_ type: Value.Type = Value.self, atIndex index: Swift.Int) throws -> Value where Value : GRDB.DatabaseValueConvertible {
        _checkIndex(index)
        return try Value.decode(fromRow: self, atUncheckedIndex: index)
    }
  @inlinable final internal func decode<Value>(_ type: Value.Type = Value.self, forKey columnName: Swift.String) throws -> Value where Value : GRDB.DatabaseValueConvertible {
        guard let index = index(forColumn: columnName) else {
            if let value = Value.fromMissingColumn() {
                return value
            } else {
                throw RowDecodingError.columnNotFound(columnName, context: RowDecodingContext(row: self))
            }
        }
        return try Value.decode(fromRow: self, atUncheckedIndex: index)
    }
}
extension GRDB.Row {
  @inline(__always) @inlinable final internal func decode<Value>(_ type: Value.Type = Value.self, atIndex index: Swift.Int) throws -> Value where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible {
        _checkIndex(index)
        return try Value.fastDecode(fromRow: self, atUncheckedIndex: index)
    }
  @inlinable final internal func decode<Value>(_ type: Value.Type = Value.self, forKey columnName: Swift.String) throws -> Value where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible {
        guard let index = index(forColumn: columnName) else {
            if let value = Value.fromMissingColumn() {
                return value
            } else {
                throw RowDecodingError.columnNotFound(columnName, context: RowDecodingContext(row: self))
            }
        }
        return try Value.fastDecode(fromRow: self, atUncheckedIndex: index)
    }
  @usableFromInline
  final internal func fastDecode<Value>(_ type: Value.Type, atUncheckedIndex index: Swift.Int) throws -> Value where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible
}
@_hasMissingDesignatedInitializers final public class RowCursor : GRDB.DatabaseCursor {
  public typealias Element = GRDB.Row
  final public let _statement: GRDB.Statement
  final public var _isDone: Swift.Bool
  @usableFromInline
  final internal let _row: GRDB.Row
  @objc deinit
  @inlinable final public func _element(sqliteStatement: GRDB.SQLiteStatement) -> GRDB.Row { _row }
}
extension GRDB.Row {
  public static func fetchCursor(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.RowCursor
  public static func fetchAll(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> [GRDB.Row]
  public static func fetchSet(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<GRDB.Row>
  public static func fetchOne(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.Row?
}
extension GRDB.Row {
  public static func fetchCursor(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.RowCursor
  public static func fetchAll(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> [GRDB.Row]
  public static func fetchSet(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<GRDB.Row>
  public static func fetchOne(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.Row?
}
extension GRDB.Row {
  public static func fetchCursor(_ db: GRDB.Database, _ request: some FetchRequest) throws -> GRDB.RowCursor
  public static func fetchAll(_ db: GRDB.Database, _ request: some FetchRequest) throws -> [GRDB.Row]
  public static func fetchSet(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Swift.Set<GRDB.Row>
  public static func fetchOne(_ db: GRDB.Database, _ request: some FetchRequest) throws -> GRDB.Row?
}
extension GRDB.FetchRequest where Self.RowDecoder == GRDB.Row {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.RowCursor
  public func fetchAll(_ db: GRDB.Database) throws -> [GRDB.Row]
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<GRDB.Row>
  public func fetchOne(_ db: GRDB.Database) throws -> GRDB.Row?
}
extension GRDB.Row : Swift.RandomAccessCollection {
  final public var startIndex: GRDB.Row.Index {
    get
  }
  final public var endIndex: GRDB.Row.Index {
    get
  }
  final public subscript(position: GRDB.Row.Index) -> (Swift.String, GRDB.DatabaseValue) {
    get
  }
  public typealias Element = (Swift.String, GRDB.DatabaseValue)
  public typealias Indices = Swift.Range<GRDB.Row.Index>
  public typealias Iterator = Swift.IndexingIterator<GRDB.Row>
  public typealias SubSequence = Swift.Slice<GRDB.Row>
}
extension GRDB.Row : Swift.Equatable {
  public static func == (lhs: GRDB.Row, rhs: GRDB.Row) -> Swift.Bool
}
extension GRDB.Row : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension GRDB.Row : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension GRDB.Row : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension GRDB.Row : Swift.ExpressibleByDictionaryLiteral {
  convenience public init(dictionaryLiteral elements: (Swift.String, (any GRDB.DatabaseValueConvertible)?)...)
  public typealias Key = Swift.String
  public typealias Value = (any GRDB.DatabaseValueConvertible)?
}
extension GRDB.Row {
  public struct Index {
  }
}
extension GRDB.Row.Index : Swift.Equatable {
  public static func == (lhs: GRDB.Row.Index, rhs: GRDB.Row.Index) -> Swift.Bool
}
extension GRDB.Row.Index : Swift.Comparable {
  public static func < (lhs: GRDB.Row.Index, rhs: GRDB.Row.Index) -> Swift.Bool
}
extension GRDB.Row.Index : Swift.Strideable {
  public func distance(to other: GRDB.Row.Index) -> Swift.Int
  public func advanced(by n: Swift.Int) -> GRDB.Row.Index
  public typealias Stride = Swift.Int
}
extension GRDB.Row {
  public struct ScopesView {
    public var names: Swift.Dictionary<Swift.String, any GRDB._LayoutedRowAdapter>.Keys {
      get
    }
    public subscript(name: Swift.String) -> GRDB.Row? {
      get
    }
  }
}
extension GRDB.Row.ScopesView : Swift.Collection {
  public typealias Index = Swift.Dictionary<Swift.String, any GRDB._LayoutedRowAdapter>.Index
  public var startIndex: GRDB.Row.ScopesView.Index {
    get
  }
  public var endIndex: GRDB.Row.ScopesView.Index {
    get
  }
  public func index(after i: GRDB.Row.ScopesView.Index) -> GRDB.Row.ScopesView.Index
  public subscript(position: GRDB.Row.ScopesView.Index) -> (name: Swift.String, row: GRDB.Row) {
    get
  }
  public typealias Element = (name: Swift.String, row: GRDB.Row)
  public typealias Indices = Swift.DefaultIndices<GRDB.Row.ScopesView>
  public typealias Iterator = Swift.IndexingIterator<GRDB.Row.ScopesView>
  public typealias SubSequence = Swift.Slice<GRDB.Row.ScopesView>
}
extension GRDB.Row {
  public struct ScopesTreeView {
    public var names: Swift.Set<Swift.String> {
      get
    }
    public subscript(name: Swift.String) -> GRDB.Row? {
      get
    }
  }
}
extension GRDB.Row {
  public struct PrefetchedRowsView : Swift.Equatable {
    public var isEmpty: Swift.Bool {
      get
    }
    public var keys: Swift.Set<Swift.String> {
      get
    }
    public subscript(key: Swift.String) -> [GRDB.Row]? {
      get
    }
    public static func == (a: GRDB.Row.PrefetchedRowsView, b: GRDB.Row.PrefetchedRowsView) -> Swift.Bool
  }
}
public struct HasOneAssociation<Origin, Destination> {
  public var _sqlAssociation: GRDB._SQLAssociation
}
extension GRDB.HasOneAssociation : GRDB.AssociationToOne {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
}
extension Swift.Bool : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  public init(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Bool?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Int : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = Int(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Int?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Int8 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = Int8(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Int8?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Int16 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = Int16(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Int16?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Int32 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = Int32(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Int32?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Int64 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  public init(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Int64?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.UInt : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = UInt(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.UInt?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.UInt8 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = UInt8(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.UInt8?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.UInt16 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = UInt16(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.UInt16?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.UInt32 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = UInt32(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.UInt32?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.UInt64 : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt) {
        let int64 = sqlite3_column_int64(sqliteStatement, index)
        guard let v = UInt64(exactly: int64) else { return nil }
        self = v
    }
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.UInt64?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Double : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  public init(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Double?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.Float : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  public init(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.Float?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension Swift.String : GRDB.DatabaseValueConvertible, GRDB.StatementColumnConvertible {
  public init(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Swift.String?
  public func bind(to sqliteStatement: GRDB.SQLiteStatement, at index: Swift.CInt) -> Swift.CInt
}
extension GRDB.DatabaseFunction {
  public static let capitalize: GRDB.DatabaseFunction
  public static let lowercase: GRDB.DatabaseFunction
  public static let uppercase: GRDB.DatabaseFunction
  public static let localizedCapitalize: GRDB.DatabaseFunction
  public static let localizedLowercase: GRDB.DatabaseFunction
  public static let localizedUppercase: GRDB.DatabaseFunction
}
extension GRDB.DatabaseCollation {
  public static let unicodeCompare: GRDB.DatabaseCollation
  public static let caseInsensitiveCompare: GRDB.DatabaseCollation
  public static let localizedCaseInsensitiveCompare: GRDB.DatabaseCollation
  public static let localizedCompare: GRDB.DatabaseCollation
  public static let localizedStandardCompare: GRDB.DatabaseCollation
}
@_hasMissingDesignatedInitializers public class TableAlias {
  public init(name: Swift.String? = nil)
  public subscript(selectable: some SQLSelectable) -> GRDB.SQLSelection {
    get
  }
  public subscript(expression: some SQLSpecificExpressible & SQLSelectable & SQLOrderingTerm) -> GRDB.SQLExpression {
    get
  }
  public subscript(ordering: some SQLOrderingTerm) -> GRDB.SQLOrdering {
    get
  }
  public subscript(column: Swift.String) -> GRDB.SQLExpression {
    get
  }
  public var exists: GRDB.SQLExpression {
    get
  }
  @objc deinit
}
extension GRDB.TableAlias : Swift.Equatable {
  public static func == (lhs: GRDB.TableAlias, rhs: GRDB.TableAlias) -> Swift.Bool
}
extension GRDB.TableAlias : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MutablePersistableRecord : GRDB.EncodableRecord, GRDB.TableRecord {
  static var persistenceConflictPolicy: GRDB.PersistenceConflictPolicy { get }
  mutating func willInsert(_ db: GRDB.Database) throws
  func aroundInsert(_ db: GRDB.Database, insert: () throws -> GRDB.InsertionSuccess) throws
  mutating func didInsert(_ inserted: GRDB.InsertionSuccess)
  func willUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>) throws
  func aroundUpdate(_ db: GRDB.Database, columns: Swift.Set<Swift.String>, update: () throws -> GRDB.PersistenceSuccess) throws
  func didUpdate(_ updated: GRDB.PersistenceSuccess)
  func willSave(_ db: GRDB.Database) throws
  func aroundSave(_ db: GRDB.Database, save: () throws -> GRDB.PersistenceSuccess) throws
  func didSave(_ saved: GRDB.PersistenceSuccess)
  func willDelete(_ db: GRDB.Database) throws
  func aroundDelete(_ db: GRDB.Database, delete: () throws -> Swift.Bool) throws
  func didDelete(deleted: Swift.Bool)
}
extension GRDB.MutablePersistableRecord {
  public static var persistenceConflictPolicy: GRDB.PersistenceConflictPolicy {
    get
  }
  @usableFromInline
  internal func persistenceCallbackMisuse(_ callbackName: Swift.String) throws -> Swift.Never
}
extension GRDB.MutablePersistableRecord {
  public func exists(_ db: GRDB.Database) throws -> Swift.Bool
}
public struct PersistenceConflictPolicy {
  public let conflictResolutionForInsert: GRDB.Database.ConflictResolution
  public let conflictResolutionForUpdate: GRDB.Database.ConflictResolution
  public init(insert: GRDB.Database.ConflictResolution = .abort, update: GRDB.Database.ConflictResolution = .abort)
}
public struct InsertionSuccess {
  public var rowID: Swift.Int64
  public var rowIDColumn: Swift.String?
  public var persistenceContainer: GRDB.PersistenceContainer
}
public struct PersistenceSuccess {
  public var persistenceContainer: GRDB.PersistenceContainer
  @usableFromInline
  internal init(_ inserted: GRDB.InsertionSuccess)
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Decodable {
  public static func fromDatabaseValue(_ databaseValue: GRDB.DatabaseValue) -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : Swift.Decodable, Self : Swift.RawRepresentable, Self.RawValue : GRDB.DatabaseValueConvertible {
  public static func fromDatabaseValue(_ databaseValue: GRDB.DatabaseValue) -> Self?
}
public struct HasManyAssociation<Origin, Destination> {
  public var _sqlAssociation: GRDB._SQLAssociation
}
extension GRDB.HasManyAssociation : GRDB.AssociationToMany {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
}
extension Foundation.NSData : GRDB.DatabaseValueConvertible {
  public var databaseValue: GRDB.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: GRDB.DatabaseValue) -> Self?
}
public protocol StatementColumnConvertible {
  static func fromStatement(_ sqliteStatement: GRDB.SQLiteStatement, atUncheckedIndex index: Swift.CInt) -> Self?
  init?(sqliteStatement: GRDB.SQLiteStatement, index: Swift.CInt)
}
extension GRDB.StatementColumnConvertible {
  @inline(__always) @inlinable public static func fromStatement(_ sqliteStatement: GRDB.SQLiteStatement, atUncheckedIndex index: Swift.CInt) -> Self? {
        if sqlite3_column_type(sqliteStatement, index) == SQLITE_NULL {
            return nil
        }
        return self.init(sqliteStatement: sqliteStatement, index: index)
    }
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible {
  @usableFromInline
  internal static func _valueMismatch(fromStatement sqliteStatement: GRDB.SQLiteStatement, atUncheckedIndex index: Swift.CInt, context: @autoclosure () -> GRDB.RowDecodingContext) throws -> Swift.Never
  @inline(__always) @inlinable internal static func fastDecode(fromRow row: GRDB.Row, atUncheckedIndex index: Swift.Int) throws -> Self {
        if let sqliteStatement = row.sqliteStatement {
            return try fastDecode(
                fromStatement: sqliteStatement,
                atUncheckedIndex: CInt(index),
                context: RowDecodingContext(row: row, key: .columnIndex(index)))
        }
        // Support for fast decoding from adapted rows
        return try row.fastDecode(Self.self, atUncheckedIndex: index)
    }
  @inline(__always) @inlinable internal static func fastDecode(fromStatement sqliteStatement: GRDB.SQLiteStatement, atUncheckedIndex index: Swift.CInt, context: @autoclosure () -> GRDB.RowDecodingContext) throws -> Self {
        if let value = fromStatement(sqliteStatement, atUncheckedIndex: index) {
            return value
        } else {
            try _valueMismatch(fromStatement: sqliteStatement, atUncheckedIndex: index, context: context())
        }
    }
  @inline(__always) @inlinable internal static func fastDecodeIfPresent(fromRow row: GRDB.Row, atUncheckedIndex index: Swift.Int) throws -> Self? {
        try Optional<Self>.fastDecode(fromRow: row, atUncheckedIndex: index)
    }
}
@_hasMissingDesignatedInitializers final public class FastDatabaseValueCursor<Value> : GRDB.DatabaseCursor where Value : GRDB.DatabaseValueConvertible, Value : GRDB.StatementColumnConvertible {
  public typealias Element = Value
  final public let _statement: GRDB.Statement
  final public var _isDone: Swift.Bool
  @usableFromInline
  final internal let columnIndex: Swift.CInt
  @objc deinit
  @inlinable final public func _element(sqliteStatement: GRDB.SQLiteStatement) throws -> Value {
        try Value.fastDecode(
            fromStatement: sqliteStatement,
            atUncheckedIndex: columnIndex,
            context: RowDecodingContext(statement: _statement, index: Int(columnIndex)))
    }
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible {
  public static func fetchCursor(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.FastDatabaseValueCursor<Self>
  public static func fetchAll(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible, Self : Swift.Hashable {
  public static func fetchSet(_ statement: GRDB.Statement, arguments: GRDB.StatementArguments? = nil, adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<Self>
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible {
  public static func fetchCursor(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> GRDB.FastDatabaseValueCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible, Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, sql: Swift.String, arguments: GRDB.StatementArguments = StatementArguments(), adapter: (any GRDB.RowAdapter)? = nil) throws -> Swift.Set<Self>
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible {
  public static func fetchCursor(_ db: GRDB.Database, _ request: some FetchRequest) throws -> GRDB.FastDatabaseValueCursor<Self>
  public static func fetchAll(_ db: GRDB.Database, _ request: some FetchRequest) throws -> [Self]
  public static func fetchOne(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Self?
}
extension GRDB.DatabaseValueConvertible where Self : GRDB.StatementColumnConvertible, Self : Swift.Hashable {
  public static func fetchSet(_ db: GRDB.Database, _ request: some FetchRequest) throws -> Swift.Set<Self>
}
extension GRDB.FetchRequest where Self.RowDecoder : GRDB.DatabaseValueConvertible, Self.RowDecoder : GRDB.StatementColumnConvertible {
  public func fetchCursor(_ db: GRDB.Database) throws -> GRDB.FastDatabaseValueCursor<Self.RowDecoder>
  public func fetchAll(_ db: GRDB.Database) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: GRDB.Database) throws -> Self.RowDecoder?
}
extension GRDB.FetchRequest where Self.RowDecoder : GRDB.DatabaseValueConvertible, Self.RowDecoder : GRDB.StatementColumnConvertible, Self.RowDecoder : Swift.Hashable {
  public func fetchSet(_ db: GRDB.Database) throws -> Swift.Set<Self.RowDecoder>
}
public struct SQLExpression {
  public struct AssociativeBinaryOperator : Swift.Hashable {
    public static let add: GRDB.SQLExpression.AssociativeBinaryOperator
    public static let multiply: GRDB.SQLExpression.AssociativeBinaryOperator
    public static let and: GRDB.SQLExpression.AssociativeBinaryOperator
    public static let or: GRDB.SQLExpression.AssociativeBinaryOperator
    public static let concat: GRDB.SQLExpression.AssociativeBinaryOperator
    public static let bitwiseAnd: GRDB.SQLExpression.AssociativeBinaryOperator
    public static let bitwiseOr: GRDB.SQLExpression.AssociativeBinaryOperator
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: GRDB.SQLExpression.AssociativeBinaryOperator, b: GRDB.SQLExpression.AssociativeBinaryOperator) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol SQLExpressible {
  var sqlExpression: GRDB.SQLExpression { get }
}
extension GRDB.SQLExpressible where Self == GRDB.Column {
  public static var rowID: GRDB.Column {
    get
  }
}
public protocol SQLSpecificExpressible : GRDB.SQLExpressible, GRDB.SQLOrderingTerm, GRDB.SQLSelectable {
}
extension GRDB.SQLSpecificExpressible {
  public var sqlSelection: GRDB.SQLSelection {
    get
  }
  public var sqlOrdering: GRDB.SQLOrdering {
    get
  }
}
extension GRDB.SQLExpression : GRDB.SQLSpecificExpressible {
  @available(*, deprecated, message: "Already SQLExpression")
  public var sqlExpression: GRDB.SQLExpression {
    get
  }
}
extension Swift.Sequence where Self.Element : GRDB.SQLSpecificExpressible {
  public func joined(operator: GRDB.SQLExpression.AssociativeBinaryOperator) -> GRDB.SQLExpression
}
extension Swift.Sequence where Self.Element == any GRDB.SQLSpecificExpressible {
  public func joined(operator: GRDB.SQLExpression.AssociativeBinaryOperator) -> GRDB.SQLExpression
}
extension GRDB.SQLSpecificExpressible {
  public var asc: GRDB.SQLOrdering {
    get
  }
  public var desc: GRDB.SQLOrdering {
    get
  }
  @available(iOS 14, macOS 11.0, tvOS 14, watchOS 7, *)
  public var ascNullsLast: GRDB.SQLOrdering {
    get
  }
  @available(iOS 14, macOS 11.0, tvOS 14, watchOS 7, *)
  public var descNullsFirst: GRDB.SQLOrdering {
    get
  }
}
extension GRDB.SQLSpecificExpressible {
  public func forKey(_ key: Swift.String) -> GRDB.SQLSelection
  public func forKey(_ key: some CodingKey) -> GRDB.SQLSelection
}
extension GRDB.SQLSpecificExpressible {
  public func collating(_ collation: GRDB.Database.CollationName) -> GRDB.SQLExpression
  public func collating(_ collation: GRDB.DatabaseCollation) -> GRDB.SQLExpression
}
public struct FTS5 {
  public enum Diacritics {
    case keep
    case removeLegacy
    @available(iOS 14, macOS 11.0, tvOS 14, watchOS 7, *)
    case remove
    public static func == (a: GRDB.FTS5.Diacritics, b: GRDB.FTS5.Diacritics) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init()
  public static func api(_ db: GRDB.Database) -> Swift.UnsafePointer<SQLite3.fts5_api>
}
extension GRDB.FTS5 : GRDB.VirtualTableModule {
  public var moduleName: Swift.String {
    get
  }
  public func makeTableDefinition(configuration: GRDB.VirtualTableConfiguration) -> GRDB.FTS5TableDefinition
  public func moduleArguments(for definition: GRDB.FTS5TableDefinition, in db: GRDB.Database) throws -> [Swift.String]
  public func database(_ db: GRDB.Database, didCreate tableName: Swift.String, using definition: GRDB.FTS5TableDefinition) throws
  public typealias TableDefinition = GRDB.FTS5TableDefinition
}
@_hasMissingDesignatedInitializers final public class FTS5TableDefinition {
  final public var tokenizer: GRDB.FTS5TokenizerDescriptor?
  final public var content: Swift.String? {
    get
    set
  }
  final public var contentRowID: Swift.String? {
    get
    set
  }
  final public var prefixes: Swift.Set<Swift.Int>?
  final public var columnSize: Swift.Int?
  final public var detail: Swift.String?
  @discardableResult
  final public func column(_ name: Swift.String) -> GRDB.FTS5ColumnDefinition
  final public func synchronize(withTable tableName: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FTS5ColumnDefinition {
  @discardableResult
  final public func notIndexed() -> Self
  @objc deinit
}
extension GRDB.Column {
  public static let rank: GRDB.Column
}
extension GRDB.Database {
  final public func dropFTS5SynchronizationTriggers(forTable tableName: Swift.String) throws
}
extension GRDB.DatabaseUUIDEncodingStrategy : Swift.Equatable {}
extension GRDB.DatabaseUUIDEncodingStrategy : Swift.Hashable {}
extension GRDB.Database.TransactionObservationExtent : Swift.Equatable {}
extension GRDB.Database.TransactionObservationExtent : Swift.Hashable {}
extension GRDB.DatabaseEventKind : Swift.Sendable {}
extension GRDB.DatabaseEvent.Kind : Swift.Equatable {}
extension GRDB.DatabaseEvent.Kind : Swift.Hashable {}
extension GRDB.DatabaseEvent.Kind : Swift.RawRepresentable {}
extension GRDB.DatabasePreUpdateEvent.Kind : Swift.Equatable {}
extension GRDB.DatabasePreUpdateEvent.Kind : Swift.Hashable {}
extension GRDB.DatabasePreUpdateEvent.Kind : Swift.RawRepresentable {}
extension GRDB.FTS3.Diacritics : Swift.Equatable {}
extension GRDB.FTS3.Diacritics : Swift.Hashable {}
extension GRDB.DatabaseMigrator.ForeignKeyChecks : Swift.Equatable {}
extension GRDB.DatabaseMigrator.ForeignKeyChecks : Swift.Hashable {}
extension GRDB.ColumnDefinition.GeneratedColumnQualification : Swift.Equatable {}
extension GRDB.ColumnDefinition.GeneratedColumnQualification : Swift.Hashable {}
extension GRDB.SharedValueObservationExtent : Swift.Equatable {}
extension GRDB.SharedValueObservationExtent : Swift.Hashable {}
extension GRDB.DatabaseDateComponents.Format : Swift.Equatable {}
extension GRDB.DatabaseDateComponents.Format : Swift.Hashable {}
extension GRDB.DatabaseDateComponents.Format : Swift.RawRepresentable {}
extension GRDB.Database.CheckpointMode : Swift.Equatable {}
extension GRDB.Database.CheckpointMode : Swift.Hashable {}
extension GRDB.Database.CheckpointMode : Swift.RawRepresentable {}
extension GRDB.Database.ConflictResolution : Swift.Equatable {}
extension GRDB.Database.ConflictResolution : Swift.Hashable {}
extension GRDB.Database.ConflictResolution : Swift.RawRepresentable {}
extension GRDB.Database.ForeignKeyAction : Swift.Equatable {}
extension GRDB.Database.ForeignKeyAction : Swift.Hashable {}
extension GRDB.Database.ForeignKeyAction : Swift.RawRepresentable {}
extension GRDB.Database.TransactionCompletion : Swift.Equatable {}
extension GRDB.Database.TransactionCompletion : Swift.Hashable {}
extension GRDB.Database.TransactionCompletion : Swift.Sendable {}
extension GRDB.Database.TransactionKind : Swift.Equatable {}
extension GRDB.Database.TransactionKind : Swift.Hashable {}
extension GRDB.Database.TransactionKind : Swift.RawRepresentable {}
extension GRDB.FTS5.Diacritics : Swift.Equatable {}
extension GRDB.FTS5.Diacritics : Swift.Hashable {}
